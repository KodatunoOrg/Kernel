#include "KodatunoKernel.h"
#include "NURBS.h"
#include <algorithm>

// Function: CalcNurbsCCoord
// 指定したノットtでのNURBS曲線の座標値を求める
//
// Parameters:
// *NurbsC - 対象とするNURBS曲線へのポインタ
// t - ノット値
//
// Return:
// 座標値
Coord NURBSC::CalcNurbsCCoord(double t) const
{
	Coord p;
	Coord bscpw;
	double bsw=0;
	double bs=0;

	for(size_t i=0;i<m_vCp.size();i++){
		bs = CalcBSbasis(t,m_T,i,m_M);      // Bスプライン基底関数を求める
		bsw += bs*m_W[i];					// 分母
		bscpw += m_vCp[i] * (bs*m_W[i]);		// 分子
	}
	
	p = bscpw / bsw;	// 座標値を求める

	return p;
}

// Function: CalcNurbsCCoords
// 指定したノットt群でのNURBS曲線の座標値を求める
//
// Parameters:
// *NurbsS - NURBS曲面へのポインタ   
// Ptnum - 求める点群の数   
// *T - tパラメータ群を格納した配列
// *Pt - 実座標値を格納
VCoord NURBSC::CalcNurbsCCoords(const Vdouble& T) const
{
	VCoord	Pt;
	for(size_t i=0; i<T.size(); i++){
		Pt.push_back(CalcNurbsCCoord(T[i]));
	}
	return Pt;
}

// Function: GenRotNurbsS
// NurbsCを原点を通るAxis回りにdegだけ回転させた回転サーフェスNurbsSを生成する
//
// Parameter:
// *NurbsS - 生成される回転サーフェス(NURBS曲面)へのポインタ
// NurbsC - 基線となるNURBS曲線
// Axis - 回転軸ベクトル
// deg - 回転角度（deg)
//
// Return:
// 成功：KOD_TRUE, 失敗：KOD_ERR
NURBSS* NURBSC::GenRotNurbsS(const Coord& Axis, double deg) const
{
	NURBSS* NurbsS = NULL;
	Coord norm( Axis.NormalizeVec() );		// 正規化
	int K = m_vCp.size();

    // 回転角度によって，いくつのセグメントで円弧を生成するか判断する
    // 回転角度が180度未満の場合，1セグメントで円弧を表現する
    if(fabs(deg) < 180 ){
        ublasVector S(6);					// u方向ノットベクトル
		S[0]=0;	S[1]=0;	S[2]=0;
		S[3]=1;	S[4]=1;	S[5]=1;
        ublasMatrix W(3,K);					// ウエイト
        VVCoord		Cp;						// コントロールポイント
        double rad = DegToRad(deg);
        for(int i=0;i<3;i++){
			VCoord cp;
            for(int j=0;j<K;j++){
                Coord Q_  = m_vCp[j].CalcRotVec(norm,(double)i*rad/2);	// 元々のNURBS曲線上のコントロールポイントをAxis周りに0,deg/2,deg度回転
                Coord P   = m_vCp[j].CalcNormalLine(Coord(),norm);		// Axis上の回転中心の座標
                Coord PQ_ = Q_ - P;	// PQ_ベクトルを生成
                if(i%2 == 0){		// i=0,2のとき
                    W(i,j) = m_W[j];
                    cp.push_back(Q_);
                }
                else{
                    W(i,j) = m_W[j]*cos(rad/2);
                    cp.push_back(PQ_ * 1/cos(rad/2) + P);
                }
            }
			Cp.push_back(cp);
        }
        NurbsS = new NURBSS(3,m_M,S,m_T,W,Cp,0,1,0,1);		// NURBS曲面生成
    }

    // 回転角度が270未満の場合，2セグメントで円弧を表現する
    else if(fabs(deg) < 270){
		ublasVector S(8);
		S[0]=0;		S[1]=0;		S[2]=0;		S[3]=0.5;
		S[4]=0.5;	S[5]=1;		S[6]=1;		S[7]=1;
        ublasMatrix	W(5,K);				// ウエイト
        VVCoord		Cp;					// コントロールポイント
        double rad = DegToRad(deg);
        for(int i=0;i<5;i++){
			VCoord cp;
            for(int j=0;j<K;j++){
                Coord Q_  = m_vCp[j].CalcRotVec(norm,(double)i*rad/4);	// 元々のNURBS曲線上のコントロールポイントをAxis周りに0,deg/2,deg度回転
                Coord P   = m_vCp[j].CalcNormalLine(Coord(),norm);		// Axis上の回転中心の座標
                Coord PQ_ = Q_ - P;	// PQ_ベクトルを生成
                if(i%2 ==  1){	// i=1,3のとき
					W(i,j) = m_W[j]*cos(rad/4);
					cp.push_back(PQ_ * 1/cos(rad/4) + P);
                }
                else{		// i=0,2,4のとき
                    W(i,j) = m_W[j];
                    cp.push_back(Q_);
                }
            }
			Cp.push_back(cp);
        }
        NurbsS = new NURBSS(3,m_M,S,m_T,W,Cp,0,1,0,1);		// NURBS曲面生成
    }

    // 回転角度が360度未満の場合，3セグメントで円弧を表現する
    else if(fabs(deg) < 360){
		ublasVector S(10);
        S[0]=0;		S[1]=0;		S[2]=0;		S[3]=0.33;		S[4]=0.33;
		S[5]=0.66;	S[6]=0.66;	S[7]=1;		S[8]=1;			S[9]=1;
        ublasMatrix	W(7,K);				// ウエイト
        VVCoord		Cp;					// コントロールポイント
        double rad = DegToRad(deg);
        for(int i=0;i<7;i++){
			VCoord cp;
            for(int j=0;j<K;j++){
                Coord Q_  = m_vCp[j].CalcRotVec(norm,(double)i*rad/6);		// 元々のNURBS曲線上のコントロールポイントをAxis周りに0,deg/2,deg度回転
                Coord P   = m_vCp[j].CalcNormalLine(Coord(),norm);	// Axis上の回転中心の座標
                Coord PQ_ = Q_ - P;	// PQ_ベクトルを生成
                if(i%2 ==  0){	// i=0,2,4,6のとき
                    W(i,j) = m_W[j];
                    cp.push_back(Q_);
                }
                else{		// i=1,3,5のとき
                    W(i,j) = m_W[j]*cos(rad/6);
                    cp.push_back(PQ_ * 1/cos(rad/6) + P);
                }
            }
			Cp.push_back(cp);
        }
        NurbsS = new NURBSS(3,m_M,S,m_T,W,Cp,0,1,0,1);		// NURBS曲面生成
        NurbsS->DebugForNurbsS();
    }
    // 360度以上
    else{
        ublasVector S(12);				// u方向ノットベクトル
        S[0]=0;		S[1]=0;		S[2]=0;		S[3]=0.25;	S[4]=0.25;	S[5]=0.5;
		S[6]=0.5;	S[7]=0.75;	S[8]=0.75;	S[9]=1;		S[10]=1;	S[11]=1;
        ublasMatrix	W(9,K);				// ウエイト
        VVCoord		Cp;					// コントロールポイント
        for(int i=0;i<9;i++){		// u方向
			VCoord cp;
            for(int j=0;j<K;j++){	// v方向
                Coord Q_  = m_vCp[j].CalcRotVec(norm,(double)i*PI/4);		// 元々のNURBS曲線上のコントロールポイントをAxis周りに45度回転
                Coord P   = m_vCp[j].CalcNormalLine(Coord(),norm);			// Axis上の回転中心の座標
                Coord PQ_ = Q_ - P;												// PQ_ベクトルを生成
                if(i%2 == 0){													// i=0,2,4,6のとき
                    W(i,j) = m_W[j];										// ウエイト
                    cp.push_back(Q_);											// Q_がそのままコントロールポイントになる
                }
                else{															// i=1,3,5,7のとき
                    W(i,j) = m_W[j]*cos(PI/4);								// ウエイト計算
                    cp.push_back(PQ_ * 1/cos(PI/4) + P);						// コントロールポイント計算
                }
            }
			Cp.push_back(cp);
        }
		NurbsS = new NURBSS(3,m_M,S,m_T,W,Cp,0,1,0,1);		// NURBS曲面生成
    }

    return NurbsS;
}

// Function: GenSweepNurbsS
// 1つのNURBS曲線からある軸方向にある距離だけスイープさせたスイープサーフェスを生成する
//
// Parameters:
// *NurbsS - 生成されるスイープサーフェス(NURBS曲面)へのポインタ
// NurbsC - 基線となるNURBS曲線
// Axis - スイープ方向ベクトル
// Len - スイープ距離
//
// Return:
// 成功：KOD_TRUE, 失敗：KOD_ERR
NURBSS* NURBSC::GenSweepNurbsS(const Coord& Axis, double Len) const
{
	Coord norm( Axis.NormalizeVec() );		// 正規化
	int K = m_vCp.size();

	// NurbsSを生成
	ublasVector T(4);				// v方向ノットベクトル
	T[0]=0;	T[1]=0;	T[2]=1;	T[3]=1;
	ublasMatrix W(K,2);				// ウエイト
	VVCoord  Cp;					// コントロールポイント (K,2)

	for(int i=0;i<K;i++){
		VCoord cp;
		for(int j=0;j<2;j++){
			W(i,j) = m_W[i];	// ウエイト計算
			if(j==0)
				cp.push_back(m_vCp[i]);		// コントロールポイント計算
			else
				cp.push_back(m_vCp[i] + (norm * Len));		// コントロールポイント計算
		}
		Cp.push_back(cp);
	}

	return new NURBSS(m_M,2,m_T,T,W,Cp,0,1,m_V[0],m_V[1]);	// NURBS曲面生成
}

// Fucntion:CalcDiffNurbsC
// NURBS曲線の1階微分係数を求める
// 
// Paramters:
// *NurbsC - NURBS曲線へのポインタ
// t - ノット値
//
// Return:
// 計算結果
Coord NURBSC::CalcDiffNurbsC(double t) const
{
	Coord Ft,diff_Ft;		// NURBS曲線の分子
	double Gt,diff_Gt;		// NURBS曲線の分母
	double bs,diff_bs;		// Bスプライン基底関数

	Gt = 0;
	diff_Gt = 0;

	// 各係数算出
	for(size_t i=0;i<m_vCp.size();i++){
		bs = CalcBSbasis(t,m_T,i,m_M);
		diff_bs = CalcDiffBSbasis(t,m_T,i,m_M);

		Ft += m_vCp[i] * (bs*m_W[i]);
		diff_Ft += m_vCp[i] * (diff_bs*m_W[i]);

		Gt += bs*m_W[i];
		diff_Gt += diff_bs*m_W[i];
	}
	if(fabs(Gt) < APPROX_ZERO)	return(Coord());

	// 1階微分を求める
	return (diff_Ft / Gt) - ((Ft*diff_Gt)/(Gt*Gt));
}

// Function: CalcDiff2NurbsC
// NURBS曲線の2階微分係数を求める
// 
// Paramters:
// *NurbsC - NURBS曲線へのポインタ
// t - ノット値
//
// Return:
// 計算結果
Coord NURBSC::CalcDiff2NurbsC(double t) const
{
	double w0=0;
	double w1=0;
	double w2=0;
	Coord  A2;
	Coord  P0;
	Coord  P1;

	P0 = CalcNurbsCCoord(t);
	P1 = CalcDiffNurbsC(t);

	for(size_t i=0;i<m_vCp.size();i++){
		w0 += CalcBSbasis(t,m_T,i,m_M) * m_W[i];
		w1 += CalcDiffBSbasis(t,m_T,i,m_M) * m_W[i];
		w2 += CalcDiffBSbasisN(t,m_T,i,m_M,2) * m_W[i];
		A2 += m_vCp[i] * (CalcDiffBSbasisN(t,m_T,i,m_M,2) * m_W[i]);
	}

	return (A2-((P1*2*w1)+(P0*2*w2)))/w0;
}

// Function: CalcDiffNNurbsC
// NURBS曲線のr階微分係数を求める
// 
// Paramters:
// *NurbsC - NURBS曲線へのポインタ
// r - 微分階数
// t - ノット値
//
// Return:
// 計算結果
Coord NURBSC::CalcDiffNNurbsC(int r, double t) const
{
	if(!r) return CalcNurbsCCoord(t);

	int K=m_vCp.size();
	Coord Ar;
	double W = 0;

	for(int i=0;i<K;i++){
		double bsr = CalcDiffBSbasisN(t,m_T,i,m_M,r);
		Ar += m_vCp[i] * (bsr*m_W[i]);
		W  += m_W[i]*CalcBSbasis(t,m_T,i,m_M);
	}

	Coord Br;
	for(int i=1;i<=r;i++){
		double Wi = 0;
		for(int j=0;j<K;j++){
			double bsi = CalcDiffBSbasisN(t,m_T,j,m_M,i);
			Wi += bsi*m_W[j];
		}
		if(Wi == 0.0)  return(Coord());
		Br += CalcDiffNNurbsC(r-i,t) * ((double)nCr(r,i)*Wi);	// 回帰
	}

	return (Ar-Br)/W;
}

// Function: CalcIntersecPtNurbsPt
// 空間上の1点PからNURBS曲線C上の最近傍点Q(曲線パラメータ)を求める(ニュートン法)
// 
// >F(t) = (P-C'(t))･C'(t) = 0
// >F'(t)dt = -F(t)
// >F'(t) = -|C'(t)|^2 + (P+C(t))･C"(t)
//
// Parameters:
// *C - NURBS曲線
// P - 空間上の1点
// Divnum - ニュートン法初期値指定用の曲線分割数
// LoD - ニュートンパラメータ更新時のステップサイズ(1～)
// Q - 解（C上の点をtパラメータで格納）
// 
// Return:
// KOD_TRUE：収束した    KOD_FALSE:収束しなかった
boost::optional<double> NURBSC::CalcIntersecPtNurbsPt(const Coord& P, int Divnum, int LoD) const
{
	Vdouble t_buf(Divnum);					// 収束解格納用バッファ
	Vdouble dist_buf(Divnum);				// 各tでの距離格納用バッファ
	double delta = (m_V[1] - m_V[0])/(double)Divnum;	// 収束演算用のtパラメータのインターバル値

	for(int i=0;i<Divnum;i++){
		double t = m_V[0] + (double)i*delta;	// tの初期値をセット
		int loopcount = 0;
		while(loopcount < LOOPCOUNTMAX){
			Coord Ct = CalcNurbsCCoord(t);
			Coord C_ = CalcDiffNurbsC(t);
			Coord C__ = CalcDiff2NurbsC(t);
			double a = P  & C_;
			double b = Ct & C_;
			double c = C_ & C_;
			double d = (P-Ct) & C__;
			if(fabs(d-c) <= APPROX_ZERO)	break;			// 分母がゼロなら次の初期点へ
			double dt = (b-a)/(d-c);
			t += dt/(double)LoD;				// t更新
			if(fabs(dt) <= APPROX_ZERO_L){	// 収束していたら解を保持し次のtへ
				t_buf[i] = t;
				dist_buf[i] = CalcNurbsCCoord(t).CalcDistance(P);	// PQ間距離を得る
				break;
			}
			loopcount++;
			t_buf[i] = dist_buf[i] = -1;		// 収束していなかったら，エラーフラグとして-1を代入
		}
	}

	// 得られた解から，PQ間の距離が最も短いものを選択
	bool flag = false;
	double Q, min = 1E+308;
	for(int i=0;i<Divnum;i++){
		if(dist_buf[i] > 0 && dist_buf[i] < min){
			min = dist_buf[i];
			Q = t_buf[i];
			flag = true;
		}
	}
	
	return flag == true ? Q : boost::optional<double>();
}

// Function: CalcIntersecPtNurbsPtDescrete
// 空間上の1点PからNURBS曲線C上の最近傍点Qを求める(離散的)
//
// Parameters:
// *C - NURBS曲線
// P - 空間上の1点
// Divnum - 曲面分割数
// LoD - 詳細度
// Ts - t方向パラメータの探索開始値
// Te - t方向パラメータの探索終了値
// *Q - 解（C上の点をtパラメータで格納）
boost::optional<double> NURBSC::CalcIntersecPtNurbsPtDescrete(const Coord& P, int Divnum, int LoD, double Ts, double Te) const
{
    if(!LoD)    return boost::optional<double>();

    double mind = 1E+38, Q;
    Coord minp;
    double dt = (Te-Ts)/(double)Divnum;

    for(int i=0;i<=Divnum;i++){
        double t = Ts + (double)i*dt;
        if(t < m_V[0] || t > m_V[1]) continue;
        Coord p  = CalcNurbsCCoord(t);
        double d = p.CalcDistance(P);
        if(d < mind){
            mind = d;
            Q = t;
        }
    }

    boost::optional<double> ans = CalcIntersecPtNurbsPtDescrete(P,Divnum,LoD-1,Q-dt,Q+dt);

	return ans ? ans : Q;
}

// Function: CalcIntersecCurve
// NURBS曲線と平面との交点を求める(ニュートン法)
// F(t) = nvec・(C(t)-pt) = 0をニュートン法を用いて求める．
// 交点は最大で(M-1)*(K-M+1)点得られる.  (例：4階でコントロールポイントの数8個の場合、(4-1)*(8-4+1)=15点)．
// よって引数*ansは(M-1)*(K-M+1)個の配列を用意することが望ましい.
//
// Parameters:
// *nurb - NURBS曲線  
// pt - 平面上の一点  
// nvec - 平面の法線ベクトル   
// Divnum - NURBS曲線のパラメータ分割数  
// *ans - 算出された交点のtパラメータ値を格納
// ans_size - ansの配列長
// LoD - 詳細度（ニュートン法の更新パラメータを足しこむときに，LoDで割ることで，急激なパラメータ変更を避ける．通常は1でよいが，解が得られない場合は値を大きくする．2とか3とか）
//
// Return:
// 交点の個数（KOD_ERR：交点の数がans_sizeを超えた）
Vdouble NURBSC::CalcIntersecCurve(const Coord& pt, const Coord& nvec, int Divnum, int LoD) const
{
	Vdouble ans;
	double t = m_V[0];		// 現在のNURBS曲線のパラメータ値
	double d = 0;				// ニュートン法によるパラメータの更新量
	double F;					// ニュートン法の対象とする方程式
	double Ft;					// Fのtによる微分値
	double dt = (m_V[1] - m_V[0])/(double)Divnum;	// 初期点の増分値
	int loopcount = 0;			// ループ回数
	bool flag = false;			// 収束フラグ

	if(!LoD){
//		GuiIFB.SetMessage("NURBS_Func ERROR: LoD is changed 0 to 1");
		LoD = 1;
	}

	for(int i=0;i<=Divnum;i++){
		flag = false;
		loopcount = 0;
		t = m_V[0] + (double)i*dt;		// 初期値更新
		while(loopcount < LOOPCOUNTMAX){
			F  = nvec & (CalcNurbsCCoord(t)-pt);
			Ft = nvec &  CalcDiffNurbsC(t);
			d = -F/Ft;		// 更新値
			//fprintf(stderr,"   %d:%.14lf,%lf\n",i,d,t);	// for debug
			if(CheckZero(d,HIGH_ACCURACY) == KOD_TRUE){		// 更新値が閾値以下になったら、whileを抜け、解として登録
				flag = true;
				break;
			}
			t += d/(double)LoD;		// パラメータ値更新
			
			if(t < m_V[0] || t > m_V[1]){		// パラメータ範囲を超えたら、whileを抜け、次の初期値へ移行
				flag = false;
				break;
			}
			loopcount++;
		}// end of wihle
		if(flag == true){
			ans.push_back(t);		// 解として登録
		}
	}// end of i loop

	return CheckTheSamePoints(ans);		// 同一点は除去する
}

// Function: CalcIntersecCurve3 
// NURBS曲線と平面との交点を求める(3次まで対応)
// 交点は最大で(M-1)*(K-M+1)点得られる.  (例：4階でコントロールポイントの数8個の場合、(4-1)*(8-4+1)=15点)
// よって引数*ansは(M-1)*(K-M+1)個の配列を用意することが望ましい.
// 
// Parameters:
// *nurb - NURBS曲線  
// pt - 平面上の一点  
// nvec - 平面の法線ベクトル  
// *ans - 算出された交点のtパラメータ値を格納
// ans_size - ansの配列長
//
// Return:
// 交点の個数（曲線次数が3次以上：KOD_ERR）
Vdouble NURBSC::CalcIntersecCurve3(const Coord& pt, const Coord& nvec) const
{
	Vdouble ans;
	VCoord  P;	// NURBS曲線の分子の係数
	Vdouble Q;	// NURBS曲線の分母の係数
	Vdouble a;
	Vdouble t;
	int num;
	int K=m_vCp.size();

	ublasMatrix coef(m_M,m_M);

	// 1本のNURBS曲線はK-M+1本の曲線から構成される。それぞれの構成曲線に対して方程式を導出し、解を得る。
	for(int i=0;i<K-m_M+1;i++){
		if(m_M-1 == 3){			// 3次			
			coef = GetBSplCoef3(m_M,K,i,m_T);	// 各コントロールポイントにおける3次Bスプライン基底関数の係数(coef)を求める
		}
		else if(m_M-1 == 2){	// 2次
			coef = GetBSplCoef2(m_M,K,i,m_T);	// 各コントロールポイントにおける2次Bスプライン基底関数の係数を求める
		}
		else if(m_M-1 == 1){	// 1次	
			coef = GetBSplCoef1(m_M,K,i,m_T);	// 各コントロールポイントにおける1次Bスプライン基底関数の係数を求める
		}
		else{
//			char mes[256];
//			sprintf(mes,"NURBS KOD_ERROR:Ther order of equation is unsupported. (order = %d)",M-1);
//			GuiIFB.SetMessage(mes);
			goto EXIT;
		}
		boost::tie(P,Q) = GetNurbsCCoef(coef,i);	// NURBS曲線の係数(P,Q)を求める
		a = GetIntersecEquation(m_M,P,Q,pt,nvec);	// NURBS曲線と平面の交線導出用方程式を得る
		t = CalcEquation(m_M-1, a);					// 方程式を解き、交点のパラメータ値を得る

		for(size_t j=0;j<t.size();j++){
			if(t[j] >= m_T[i+m_M-1] && t[j] <= m_T[i+m_M]){	// ノットベクトルの値と適合するもののみ解として抽出
				ans.push_back(t[j]);		// 解を取得
			}
		}
	}

	return ans;

EXIT:
	return Vdouble();	// 空を返す
}

// Function: CalcIntersecPtsNurbsCNurbsCParam
// (x,y)平面上のNURBS曲線同士の交点を求める(ニュートン法)
// 
// Parameters:
// *NurbA, *NurbB - NURBS曲線
// Divnum - 初期値設定用の分割数     
// *ans - 交点格納用配列   
// ans_size - ansの配列長
// 
// Return:
// 解の個数（ans_sizeを超えたら，KOD_ERR）
VCoord NURBSC::CalcIntersecPtsNurbsCNurbsCParam(const NURBSC* NurbB, int Divnum) const
{
	VCoord ans;
	double t = m_V[0];			// 現在のNurbAのパラメータ値
	double u = 0;				// 現在のNurbBのパラメータ値
	double dt = 0;				// ニュートン法によるtパラメータの更新量
	double du = 0;				// ニュートン法によるuパラメータの更新量
	Coord F;					// ニュートン法の対象とする方程式(F(t,u) = NurbA(t) - NurbB(u))
	Coord Ft;					// Fのtによる微分値
	Coord Fu;					// Fのuによる微分値
	double d = (m_V[1] - m_V[0])/(double)Divnum;	// 初期点の増分値
	int loopcount = 0;			// ループ回数
	bool flag = false;			// 収束フラグ
	ublasMatrix A(2,2);			// Ft,Fuを成分ごとに格納した行列
	ublasMatrix A_(2,2);		// Aの逆行列を格納
	boost::optional<ublasMatrix> reA;

	for(int i=0;i<Divnum;i++){
		flag = false;
		loopcount = 0;
		t =        m_V[0] + (double)i*d;		// 初期値更新
        u = NurbB->m_V[0];
		while(loopcount < LOOPCOUNTMAX){
			F  = CalcNurbsCCoord(t) - NurbB->CalcNurbsCCoord(u);
			Ft = CalcDiffNurbsC(t);
			Fu = NurbB->CalcDiffNurbsC(u);
			A(0,0) = Ft.x;
            A(0,1) = -Fu.x;
			A(1,0) = Ft.y;
            A(1,1) = -Fu.y;
			reA = MatInv2(A);
			if ( reA ) A_ = *reA;	// オリジナルでチェックせず
			dt = -(A_(0,0)*F.x + A_(0,1)*F.y);
			du = -(A_(1,0)*F.x + A_(1,1)*F.y);

			if(CheckZero(dt,HIGH_ACCURACY) == KOD_TRUE && CheckZero(du,HIGH_ACCURACY) == KOD_TRUE){		// 更新値が閾値以下になったら、whileを抜け、解として登録
				flag = true;
				break;
			}
            t += dt/3;		// パラメータ値更新
            u += du/3;
			if(t < m_V[0] || t > m_V[1] || u < NurbB->m_V[0] || u > NurbB->m_V[1]){		// パラメータ範囲を超えたら、whileを抜け、次の初期値へ移行
				flag = false;
				break;
			}
			loopcount++;
		}// end of wihle
		if(flag == true){
			ans.push_back(Coord(t,u));		// 解として登録
		}
	}// end of i loop

	return CheckTheSamePoints2D(ans);		// 同一点は除去する
}

// Function: ClacIntersecPtsNurbsCLine
// 2次元NURBS曲線と直線との交点を求める
//
// Parameters:
// *C - NURBS曲線
// P - 直線上の1点
// r - 直線の方向ベクトル
// *t1 - 交点におけるNURBS曲線パラメータ
// *t2 - 交点における直線パラメータ
//
// return:
// 交点の有無（KOD_TRUE：交点あり， KOD_FALSE：交点なし）
boost::optional<A2double> NURBSC::ClacIntersecPtsNurbsCLine(const Coord& P, const Coord& r) const
{
	A2double	t;
    ublasMatrix A(2,2);
    ublasMatrix A_(2,2);
	boost::optional<ublasMatrix> reA;
    bool conv_flag = false;

    t[0] = (m_V[0]+m_V[1])/2;
    t[1] = 0;

    while(1){
        Coord Ct = CalcDiffNurbsC(t[0]);
        Coord Lt = r;
        Coord B = (P+(r*(t[1]))) - CalcNurbsCCoord(t[0]);
        A(0,0) = Ct.x;
        A(1,0) = Ct.y;
        A(0,1) = -Lt.x;
        A(1,1) = -Lt.y;
		reA = MatInv2(A);
		if ( reA ) A_ = *reA;
		else break;	// 行列式がゼロ
        double dt1 = A_(0,0)*B.x + A_(0,1)*B.y;
        double dt2 = A_(1,0)*B.x + A_(1,1)*B.y;
        //fprintf(stderr,"    %lf,%lf,%lf,%lf,%lf\n",*t1,*t2,dt1,dt2,det);		// fro debug
        if(CheckZero(dt1,LOW_ACCURACY) == KOD_TRUE && CheckZero(dt2,LOW_ACCURACY) == KOD_TRUE){		// 交点に収束したらwhile break
            conv_flag = true;
            break;
        }
        else{
            t[0] += dt1/3;
            t[1] += dt2/3;
        }
        if(t[0] < m_V[0] || t[0] > m_V[1])	// 現在注目中のエッジの範囲を超えたらbreak
            break;
    }

    if(conv_flag == true)
        return t;
    else
        return boost::optional<A2double>();
}

// Function: ClacIntersecPtsNurbsCLineSeg
// 2次元NURBS曲線と線分との交点を求める
//
// Parameters:
// *C - NURBS曲線
// P - 線分上の1点
// r - 線分の方向ベクトル
// ts - 線分の始点パラメータ
// te - 線分の終点パラメータ
// *t1 - 交点におけるNURBS曲線パラメータ
// *t2 - 交点における直線パラメータ
//
// return:
// 交点の有無（KOD_TRUE：交点あり， KOD_FALSE：交点なし）
boost::optional<A2double> NURBSC::ClacIntersecPtsNurbsCLineSeg(const Coord& P, const Coord& r, double ts, double te) const
{
	boost::optional<A2double> t = ClacIntersecPtsNurbsCLine(P,r);
    if(t){
        if((*t)[1] >= ts && (*t)[1] <= te){
            return t;
        }
    }

    return boost::optional<A2double>();
}

// Function: CalcNurbsCLength
// NURBS曲線C(t)の全区間の線分長Lを求める
//
// L = S|C'(t)|dt	(Sは積分記号)
//
// 積分は数値積分(ガウス-ルジャンドルの80分点)を用いる
//
// Parameters:
// *Nurb - 対象となるNURBS曲線
//
// Return:
// 線分長
double NURBSC::CalcNurbsCLength(void) const
{
	double g[80] = {-0.9995538226516306298800804990945671849917
		,-0.997649864398237688899494208183122985331
		,-0.994227540965688277892063503664911698088
		,-0.989291302499755531026503167136631385282
		,-0.982848572738629070418288027709116473568
		,-0.974909140585727793385645230069136276245
		,-0.965485089043799251452273155671454998502
		,-0.954590766343634905493481517021029508783
		,-0.942242761309872674752266004500001735070
		,-0.928459877172445795953045959075453133792
		,-0.913263102571757654164733656150947478111
		,-0.896675579438770683194324071967395986307
		,-0.878722567678213828703773343639124407935
		,-0.859431406663111096977192123491656492839
		,-0.838831473580255275616623043902867064793
		,-0.816954138681463470371124994012295707742
		,-0.793832717504605449948639311738454358610
		,-0.769502420135041373865616068749026083985
		,-0.744000297583597272316540527930913673808
		,-0.717365185362099880254068258293815278566
		,-0.689637644342027600771207612438935266089
		,-0.660859898986119801735967122844317234805
		,-0.631075773046871966247928387289336863089
		,-0.600330622829751743154746299164006848430
		,-0.568671268122709784725485786624827158742
		,-0.536145920897131932019857253125400904911
		,-0.502804111888784987593672750367568003564
		,-0.468696615170544477036078364935808657294
		,-0.433875370831756093062386700363181958302
		,-0.398393405881969227024379642517533757117
		,-0.362304753499487315619043286358963588017
		,-0.325664370747701914619112943627358695037
		,-0.288528054884511853109139301434713898496
		,-0.250952358392272120493158816035004797363
		,-0.212994502857666132572388538666321823094
		,-0.174712291832646812559339048011286195718
		,-0.136164022809143886559241078000717067933
		,-0.097408398441584599063278450104936902017
		,-0.058504437152420668628993321883417794425
		,-0.019511383256793997654351234107454547933
		,0.0195113832567939976543512341074545479335
		,0.0585044371524206686289933218834177944254
		,0.0974083984415845990632784501049369020170
		,0.1361640228091438865592410780007170679331
		,0.1747122918326468125593390480112861957188
		,0.2129945028576661325723885386663218230948
		,0.2509523583922721204931588160350047973630
		,0.2885280548845118531091393014347138984964
		,0.3256643707477019146191129436273586950370
		,0.3623047534994873156190432863589635880171
		,0.3983934058819692270243796425175337571172
		,0.4338753708317560930623867003631819583021
		,0.4686966151705444770360783649358086572940
		,0.5028041118887849875936727503675680035649
		,0.5361459208971319320198572531254009049117
		,0.5686712681227097847254857866248271587420
		,0.6003306228297517431547462991640068484301
		,0.6310757730468719662479283872893368630891
		,0.6608598989861198017359671228443172348051
		,0.6896376443420276007712076124389352660897
		,0.7173651853620998802540682582938152785668
		,0.7440002975835972723165405279309136738087
		,0.7695024201350413738656160687490260839854
		,0.7938327175046054499486393117384543586106
		,0.8169541386814634703711249940122957077428
		,0.8388314735802552756166230439028670647936
		,0.8594314066631110969771921234916564928399
		,0.8787225676782138287037733436391244079359
		,0.8966755794387706831943240719673959863073
		,0.9132631025717576541647336561509474781115
		,0.9284598771724457959530459590754531337922
		,0.9422427613098726747522660045000017350708
		,0.9545907663436349054934815170210295087836
		,0.9654850890437992514522731556714549985029
		,0.9749091405857277933856452300691362762450
		,0.9828485727386290704182880277091164735687
		,0.9892913024997555310265031671366313852822
		,0.9942275409656882778920635036649116980888
		,0.9976498643982376888994942081831229853311
		,0.9995538226516306298800804990945671849917
	};
	double w[80] = {0.00114495000318694153454417194131563611869939240558
		,0.0026635335895126816692935358316684554657445542424
		,0.0041803131246948952367393042016813513235494973731
		,0.0056909224514031986492691071171620184769252638347
		,0.0071929047681173127526755708679565074765070381923
		,0.0086839452692608584264094522040342813524060429550
		,0.0101617660411030645208318503524069436640457818796
		,0.0116241141207978269164667699954326348595131815029
		,0.0130687615924013392937868258970563403104186343824
		,0.0144935080405090761169620745834605500559568721551
		,0.0158961835837256880449029092291785257709720926057
		,0.0172746520562693063585842071312909998003110293040
		,0.0186268142082990314287354141521572090084477663361
		,0.0199506108781419989288919287151135633605010642850
		,0.0212440261157820063887107372506131285464689242433
		,0.0225050902463324619262215896861687390205795883718
		,0.0237318828659301012931925246135684162923425291083
		,0.0249225357641154911051178470032198023571024898755
		,0.0260752357675651179029687436002692871256974758292
		,0.0271882275004863806744187066805442598298771757001
		,0.0282598160572768623967531979650145302942654983731
		,0.0292883695832678476927675860195791396612074311446
		,0.0302723217595579806612200100909011747473420675596
		,0.0312101741881147016424428667206035518659997208202
		,0.0321004986734877731480564902872506960895167638325
		,0.0329419393976454013828361809019595361280270376927
		,0.0337332149846115228166751630642387284458265038481
		,0.0344731204517539287943642267310298320767807967429
		,0.0351605290447475934955265923886968812291624523105
		,0.0357943939534160546028615888161544542402361352305
		,0.0363737499058359780439649910465228136600628217876
		,0.0368977146382760088391509965734052192685681011318
		,0.0373654902387304900267053770578386691648069079494
		,0.0377763643620013974897749764263210547707019240195
		,0.0381297113144776383442067915657362019141439239065
		,0.0384249930069594231852124363294901384310218762709
		,0.0386617597740764633270771102671566912609009278398
		,0.0388396510590519689317741826687871658908802293404
		,0.0389583959627695311986255247722608223149320115862
		,0.0390178136563066548112804392527540483295504740296
		,0.0390178136563066548112804392527540483295504740296
		,0.0389583959627695311986255247722608223149320115862
		,0.0388396510590519689317741826687871658908802293404
		,0.0386617597740764633270771102671566912609009278398
		,0.0384249930069594231852124363294901384310218762709
		,0.0381297113144776383442067915657362019141439239065
		,0.0377763643620013974897749764263210547707019240195
		,0.0373654902387304900267053770578386691648069079494
		,0.0368977146382760088391509965734052192685681011318
		,0.0363737499058359780439649910465228136600628217876
		,0.0357943939534160546028615888161544542402361352305
		,0.0351605290447475934955265923886968812291624523105
		,0.0344731204517539287943642267310298320767807967429
		,0.0337332149846115228166751630642387284458265038481
		,0.0329419393976454013828361809019595361280270376927
		,0.0321004986734877731480564902872506960895167638325
		,0.0312101741881147016424428667206035518659997208202
		,0.0302723217595579806612200100909011747473420675596
		,0.0292883695832678476927675860195791396612074311446
		,0.0282598160572768623967531979650145302942654983731
		,0.0271882275004863806744187066805442598298771757001
		,0.0260752357675651179029687436002692871256974758292
		,0.0249225357641154911051178470032198023571024898755
		,0.0237318828659301012931925246135684162923425291083
		,0.0225050902463324619262215896861687390205795883718
		,0.0212440261157820063887107372506131285464689242433
		,0.0199506108781419989288919287151135633605010642850
		,0.0186268142082990314287354141521572090084477663361
		,0.0172746520562693063585842071312909998003110293040
		,0.0158961835837256880449029092291785257709720926057
		,0.0144935080405090761169620745834605500559568721551
		,0.0130687615924013392937868258970563403104186343824
		,0.0116241141207978269164667699954326348595131815029
		,0.0101617660411030645208318503524069436640457818796
		,0.0086839452692608584264094522040342813524060429550
		,0.0071929047681173127526755708679565074765070381923
		,0.0056909224514031986492691071171620184769252638347
		,0.0041803131246948952367393042016813513235494973731
		,0.0026635335895126816692935358316684554657445542424
		,0.0011449500031869415345441719413156361186993924055
	};

	double A = (m_V[1]+m_V[0])/2;
	double B = (m_V[1]-m_V[0])/2;
	double len=0;

	for(int i=0;i<80;i++){
		double xi = A+B*g[i];
		len += w[i]*(CalcDiffNurbsC(xi).CalcEuclid());
	}
	return(B*len);
}

// Function: CalcNurbsCLength
// NURBS曲線C(t)の指定パラメータ区間[a,b]の線分長Lを求める
//
// L = S|C'(t)|dt	(Sは積分記号)
//
// 積分は数値積分(ガウス-ルジャンドルの80分点)を用いる
//
// Parameters:
// *Nurb - 対象となるNURBS曲線
// a, b - 指定パラメータ区間[a,b]
//
// Return:
// 線分長
double NURBSC::CalcNurbsCLength(double a, double b) const
{
    if(a == b) return 0;

	double g[80] = {-0.9995538226516306298800804990945671849917
		,-0.997649864398237688899494208183122985331
		,-0.994227540965688277892063503664911698088
		,-0.989291302499755531026503167136631385282
		,-0.982848572738629070418288027709116473568
		,-0.974909140585727793385645230069136276245
		,-0.965485089043799251452273155671454998502
		,-0.954590766343634905493481517021029508783
		,-0.942242761309872674752266004500001735070
		,-0.928459877172445795953045959075453133792
		,-0.913263102571757654164733656150947478111
		,-0.896675579438770683194324071967395986307
		,-0.878722567678213828703773343639124407935
		,-0.859431406663111096977192123491656492839
		,-0.838831473580255275616623043902867064793
		,-0.816954138681463470371124994012295707742
		,-0.793832717504605449948639311738454358610
		,-0.769502420135041373865616068749026083985
		,-0.744000297583597272316540527930913673808
		,-0.717365185362099880254068258293815278566
		,-0.689637644342027600771207612438935266089
		,-0.660859898986119801735967122844317234805
		,-0.631075773046871966247928387289336863089
		,-0.600330622829751743154746299164006848430
		,-0.568671268122709784725485786624827158742
		,-0.536145920897131932019857253125400904911
		,-0.502804111888784987593672750367568003564
		,-0.468696615170544477036078364935808657294
		,-0.433875370831756093062386700363181958302
		,-0.398393405881969227024379642517533757117
		,-0.362304753499487315619043286358963588017
		,-0.325664370747701914619112943627358695037
		,-0.288528054884511853109139301434713898496
		,-0.250952358392272120493158816035004797363
		,-0.212994502857666132572388538666321823094
		,-0.174712291832646812559339048011286195718
		,-0.136164022809143886559241078000717067933
		,-0.097408398441584599063278450104936902017
		,-0.058504437152420668628993321883417794425
		,-0.019511383256793997654351234107454547933
		,0.0195113832567939976543512341074545479335
		,0.0585044371524206686289933218834177944254
		,0.0974083984415845990632784501049369020170
		,0.1361640228091438865592410780007170679331
		,0.1747122918326468125593390480112861957188
		,0.2129945028576661325723885386663218230948
		,0.2509523583922721204931588160350047973630
		,0.2885280548845118531091393014347138984964
		,0.3256643707477019146191129436273586950370
		,0.3623047534994873156190432863589635880171
		,0.3983934058819692270243796425175337571172
		,0.4338753708317560930623867003631819583021
		,0.4686966151705444770360783649358086572940
		,0.5028041118887849875936727503675680035649
		,0.5361459208971319320198572531254009049117
		,0.5686712681227097847254857866248271587420
		,0.6003306228297517431547462991640068484301
		,0.6310757730468719662479283872893368630891
		,0.6608598989861198017359671228443172348051
		,0.6896376443420276007712076124389352660897
		,0.7173651853620998802540682582938152785668
		,0.7440002975835972723165405279309136738087
		,0.7695024201350413738656160687490260839854
		,0.7938327175046054499486393117384543586106
		,0.8169541386814634703711249940122957077428
		,0.8388314735802552756166230439028670647936
		,0.8594314066631110969771921234916564928399
		,0.8787225676782138287037733436391244079359
		,0.8966755794387706831943240719673959863073
		,0.9132631025717576541647336561509474781115
		,0.9284598771724457959530459590754531337922
		,0.9422427613098726747522660045000017350708
		,0.9545907663436349054934815170210295087836
		,0.9654850890437992514522731556714549985029
		,0.9749091405857277933856452300691362762450
		,0.9828485727386290704182880277091164735687
		,0.9892913024997555310265031671366313852822
		,0.9942275409656882778920635036649116980888
		,0.9976498643982376888994942081831229853311
		,0.9995538226516306298800804990945671849917
	};
	double w[80] = {0.00114495000318694153454417194131563611869939240558
		,0.0026635335895126816692935358316684554657445542424
		,0.0041803131246948952367393042016813513235494973731
		,0.0056909224514031986492691071171620184769252638347
		,0.0071929047681173127526755708679565074765070381923
		,0.0086839452692608584264094522040342813524060429550
		,0.0101617660411030645208318503524069436640457818796
		,0.0116241141207978269164667699954326348595131815029
		,0.0130687615924013392937868258970563403104186343824
		,0.0144935080405090761169620745834605500559568721551
		,0.0158961835837256880449029092291785257709720926057
		,0.0172746520562693063585842071312909998003110293040
		,0.0186268142082990314287354141521572090084477663361
		,0.0199506108781419989288919287151135633605010642850
		,0.0212440261157820063887107372506131285464689242433
		,0.0225050902463324619262215896861687390205795883718
		,0.0237318828659301012931925246135684162923425291083
		,0.0249225357641154911051178470032198023571024898755
		,0.0260752357675651179029687436002692871256974758292
		,0.0271882275004863806744187066805442598298771757001
		,0.0282598160572768623967531979650145302942654983731
		,0.0292883695832678476927675860195791396612074311446
		,0.0302723217595579806612200100909011747473420675596
		,0.0312101741881147016424428667206035518659997208202
		,0.0321004986734877731480564902872506960895167638325
		,0.0329419393976454013828361809019595361280270376927
		,0.0337332149846115228166751630642387284458265038481
		,0.0344731204517539287943642267310298320767807967429
		,0.0351605290447475934955265923886968812291624523105
		,0.0357943939534160546028615888161544542402361352305
		,0.0363737499058359780439649910465228136600628217876
		,0.0368977146382760088391509965734052192685681011318
		,0.0373654902387304900267053770578386691648069079494
		,0.0377763643620013974897749764263210547707019240195
		,0.0381297113144776383442067915657362019141439239065
		,0.0384249930069594231852124363294901384310218762709
		,0.0386617597740764633270771102671566912609009278398
		,0.0388396510590519689317741826687871658908802293404
		,0.0389583959627695311986255247722608223149320115862
		,0.0390178136563066548112804392527540483295504740296
		,0.0390178136563066548112804392527540483295504740296
		,0.0389583959627695311986255247722608223149320115862
		,0.0388396510590519689317741826687871658908802293404
		,0.0386617597740764633270771102671566912609009278398
		,0.0384249930069594231852124363294901384310218762709
		,0.0381297113144776383442067915657362019141439239065
		,0.0377763643620013974897749764263210547707019240195
		,0.0373654902387304900267053770578386691648069079494
		,0.0368977146382760088391509965734052192685681011318
		,0.0363737499058359780439649910465228136600628217876
		,0.0357943939534160546028615888161544542402361352305
		,0.0351605290447475934955265923886968812291624523105
		,0.0344731204517539287943642267310298320767807967429
		,0.0337332149846115228166751630642387284458265038481
		,0.0329419393976454013828361809019595361280270376927
		,0.0321004986734877731480564902872506960895167638325
		,0.0312101741881147016424428667206035518659997208202
		,0.0302723217595579806612200100909011747473420675596
		,0.0292883695832678476927675860195791396612074311446
		,0.0282598160572768623967531979650145302942654983731
		,0.0271882275004863806744187066805442598298771757001
		,0.0260752357675651179029687436002692871256974758292
		,0.0249225357641154911051178470032198023571024898755
		,0.0237318828659301012931925246135684162923425291083
		,0.0225050902463324619262215896861687390205795883718
		,0.0212440261157820063887107372506131285464689242433
		,0.0199506108781419989288919287151135633605010642850
		,0.0186268142082990314287354141521572090084477663361
		,0.0172746520562693063585842071312909998003110293040
		,0.0158961835837256880449029092291785257709720926057
		,0.0144935080405090761169620745834605500559568721551
		,0.0130687615924013392937868258970563403104186343824
		,0.0116241141207978269164667699954326348595131815029
		,0.0101617660411030645208318503524069436640457818796
		,0.0086839452692608584264094522040342813524060429550
		,0.0071929047681173127526755708679565074765070381923
		,0.0056909224514031986492691071171620184769252638347
		,0.0041803131246948952367393042016813513235494973731
		,0.0026635335895126816692935358316684554657445542424
		,0.0011449500031869415345441719413156361186993924055
	};

	double A = (b+a)/2;
	double B = (b-a)/2;
	double len=0;

	for(int i=0;i<80;i++){
		double xi = A+B*g[i];
		len += w[i]*(CalcDiffNurbsC(xi).CalcEuclid());
	}
	return(B*len);
}

// Function: CalcDeltaPtsOnNurbsC
// 指定した分割数でNURBS曲線上の座標値を出力する
// 
// Parameters:
// *Nurb - NURBSへのポインタ  
// D - 分割数  
// *Pts - 出力される座標値を格納
//
// Return:
// 点数
VCoord NURBSC::CalcDeltaPtsOnNurbsC(int D) const
{
	double T = (m_V[1] - m_V[0])/D;	// パラメトリック空間内での線分長を得る

	VCoord Pts;
	for(int i=0;i<=D;i++){
		Pts.push_back(CalcNurbsCCoord(m_V[0] + T*(double)i));
	}

    return Pts;
}

// Function: CalcDeltaPtsOnNurbsC
// 指定した間隔でNURBS曲線上の座標値を出力する
//
// Parameters:
// *Nurb - NURBS曲線へのポインタ  
// D - 間隔  
// *Pts - 出力される座標値を格納
//
// Return:
// 点数（Dが0，あるいは指定したNURBS曲線の全長より長かった場合は，KOD_ERR）
VCoord NURBSC::CalcDeltaPtsOnNurbsC(double D) const
{
	if(D == 0){
//		GuiIFB.SetMessage("NURBS_Func ERROR: Set Correct Interval Value");
		return VCoord();
	}

	double L = CalcNurbsCLength();		// NURBS曲線の線分長を得る
	if(D > L){
//		GuiIFB.SetMessage("NURBS_Func ERROR: Arc Length > Whole Lenth of the Curve");
	}
	//fprintf(stderr,"L = %lf\n",L);		// debug
	//fprintf(stderr,"D = %lf\n",D);		// debug

	int k=1;			// 分割カウンタ
	double t = (m_V[1] - m_V[0])/(L/D);	// tの初期値をセット
	VCoord Pts;
	while(t <= m_V[1]){
		t = CalcParamLengthOnNurbsC((double)k*D,t);	// 解を探索
		Pts.push_back(CalcNurbsCCoord(t));			// 解を登録
		k++;
		t = k*(m_V[1] - m_V[0])/(L/D);	// 次のtの初期値をセット
	}

	return Pts;
}

// Function: CalcParamLengthOnNurbsC
// NURBS曲線において一端からの指定距離におけるパラメータ値を返す
//
// Parameters:
// *C - NURBS曲線
// L - 指定距離
// Init_t - 解探索の初期パラメータ
//
// Return:
// 指定距離におけるパラメータ値
double NURBSC::CalcParamLengthOnNurbsC(double L, double Init_t) const
{
	double dt = 1E+12;			// ステップサイズパラメータの初期値
	double t = Init_t;
	int count = 0;

	while(fabs(dt) > APPROX_ZERO){
		dt = (L - CalcNurbsCLength(0,t))/CalcDiffNurbsC(t).CalcEuclid()/2;		// ニュートン法による収束計算
		t += dt;
		if(count > LOOPCOUNTMAX || t > m_V[1]){
//			GuiIFB.SetMessage("NURBS_Func ERROR: Cannot find a anser");
			break;
		}
		//fprintf(stderr,"%d:  t = %lf,    dt = %lf\n",k,t,dt);	// debug
	}

	return t;
}

// Function: CalcExtremumNurbsC
// NURBS曲線の指定した方向における極値の座標値を得る
//
// Parameters:
// *C - 極値座標を求めたいNURBS曲線へのポインタ   
// nf - 方向ベクトル     
// *pt - 得られた極値のNurbs曲線パラメータ値列    
// ptnum - *ptの配列長
//
// Return:
// 得られた極値パラメータの数（KOD_FALSE:得られなかった, KOD_ERR:極値パラメータの数がptnumを超えた）
Vdouble NURBSC::CalcExtremumNurbsC(const Coord& nf) const
{
	Vdouble pt;

	// NURBS曲線のパラメータ区間をCONVDIVNUMで区切り、それぞれに対してニュートン法による収束計算を行う
	for(int i=0;i<=CONVDIVNUM;i++){
		double t = m_V[0] + (m_V[1] - m_V[0])/CONVDIVNUM*(double)i;	// 探索開始パラメータ値
		double dt=0;					// ニュートン法用の増分値
		int lpcount=0;					// 収束計算回数
		bool flag = false;				// 例外フラグ

		// 収束計算
		while(lpcount < LOOPCOUNTMAX){
			double f_  = nf & CalcDiffNurbsC(t);
			double f__ = nf & CalcDiff2NurbsC(t);
			if(f__ == 0.0)	break;
			dt = f_/f__;

			if(CheckZero(dt,MID_ACCURACY)){			// 収束した
				flag = true;
				break;
			}
			t -= dt;	// ニュートンパラメータ更新
			if(t < m_V[0] || t > m_V[1])	break;		// 範囲外に出た
			lpcount++;
		}// End while

		// 収束していたら
		if(flag == true){
			pt.push_back(t);	// 解として登録
		}

	}// End for i

	return CheckTheSamePoints(pt);		// 同一点を除去する
}

// Function: CalcTanVecOnNurbsC
// NURBS曲線上のtにおける単位接ベクトルをもとめる
//
// Parameters:
// *C - NURBS曲線へのポインタ
// t - ノット値
//
// Retrurn:
// 計算結果
Coord NURBSC::CalcTanVecOnNurbsC(double t) const
{
    return CalcDiffNurbsC(t).NormalizeVec();
}

// Function: CalcCurvatureNurbsC
// NURBS曲線の曲率を求める
//
// Parameters:
// *C - NURBS曲線へのポインタ
// t - ノット値
//
// Retrurn:
// 計算結果
double NURBSC::CalcCurvatureNurbsC(double t) const
{
	Coord p_ = CalcDiffNurbsC(t);
	Coord p__ = CalcDiff2NurbsC(t);

	return (p_&&p__).CalcEuclid()/pow(p_.CalcEuclid(),3);
}

// Function: DivNurbsCParam
// NURBS曲線を指定したパラメータ値で分割する
//
// Parameters:
// *C0 - 分割するNURBS曲線へのポインタ        
// *C1 - 分割されたNURBS曲線へのポインタ
// *C2 - 分割されたNURBS曲線へのポインタ    
// t - 分割位置を表す曲線パラメータ
//
// Return:
// 成功：KOD_TRUE, 失敗：KOD_FALSE 
boost::tuple<NURBSC*, NURBSC*> NURBSC::DivNurbsCParam(double t) const
{
	NURBSC*	C1 = NULL;
	NURBSC*	C2 = NULL;
	int C0N = m_T.size();

	// tパラメータが適正範囲か
	if(t <= m_T[0] || t >= m_T[C0N-1]){
//		GuiIFB.SetMessage("NURBS_Func ERROR: Wrong Curve Parameter is set.");
		return boost::make_tuple(C1, C2);
	}

	int deg = m_M - 1;		// 多重度

	// C0のノットベクトルにtと同じ値がある場合は，多重度を1つ落とす
	for(int i=0;i<C0N;i++){
		if(t == m_T[i])	deg--;
	}

	// 分割の下準備
	// 分割用曲線C0_を準備する
	// 分割位置パラメータtをC0_に挿入する
	NURBSC* C0_ = new NURBSC;
	InsertNewKnotOnNurbsC(t, deg, C0_);

	// 2本の分割曲線を生成
	int k  = C0_->m_vCp.size();
	int N1 = k+1;
	int K1 = N1 - m_M;
	int N2 = C0_->m_T.size() - k + deg+1;
	int K2 = N2 - m_M;

	ublasVector T1(N1);
	ublasVector W1(K1);
	VCoord  cp1;	// (K1);
	ublasVector T2(N2);
	ublasVector W2(K2);
	VCoord  cp2;	// (K2);

	// ノットベクトル，コントロールポイント，ウェイトをC1,C2に分配
	for(int i=0;i<N1-1;i++)
		T1[i] = C0_->m_T[i];
	T1[N1-1] = t;
	for(int i=0;i<K1;i++){
		cp1.push_back(C0_->m_vCp[i]);
		W1[i] = C0_->m_W[i];
	}
	for(int i=0;i<m_M;i++)
		T2[i] = t;
	for(int i=m_M;i<N2;i++)
		T2[i] = C0_->m_T[k+i-m_M];
	for(int i=0;i<K2;i++){
		cp2.push_back(C0_->m_vCp[i+K1-1]);
		W2[i] = C0_->m_W[i+K1-1];
	}

	// debug
	//fprintf(stderr,"C0:%d,%d\n",K,N);
	//fprintf(stderr,"C0_:%d,%d\n",C0_.K,C0_.N);
	//fprintf(stderr,"C1:%d,%d\n",K1,N1);
	//fprintf(stderr,"C2:%d,%d\n",K2,N2);
	//fprintf(stderr,"\n");
	//for(int i=0;i<C0_.N;i++)
	//	fprintf(stderr,"%d:%lf\n",i+1,C0_.T[i]);
	//fprintf(stderr,"\n");
	//for(int i=0;i<N1;i++)
	//	fprintf(stderr,"%d:%lf\n",i+1,T1[i]);
	//fprintf(stderr,"\n");
	//for(int i=0;i<N2;i++)
	//	fprintf(stderr,"%d:%lf\n",i+1,T2[i]);

	delete	C0_;

	// ノットの範囲を0-1に変更
	T1 = ChangeKnotVecRange(T1,m_M,K1,0,1);
	T2 = ChangeKnotVecRange(T2,m_M,K2,0,1);

	// C1,C2生成
	C1 = new NURBSC(m_M,T1,W1,cp1,m_V,m_prop,0);
	C2 = new NURBSC(m_M,T2,W2,cp2,m_V,m_prop,0);

	return boost::make_tuple(C1, C2);
}

// Function: DivNurbsC
// NURBS曲線を指定した位置（端からの弧長）で分割する
//
// Parameters:
// *C0 - 分割するNURBS曲線へのポインタ        
// *C1 - 分割されたNURBS曲線へのポインタ
// *C2 - 分割されたNURBS曲線へのポインタ     
// L - 端からの弧長
//
// Return:
// 成功：KOD_TRUE, 失敗：KOD_FALSE 
boost::tuple<NURBSC*, NURBSC*> NURBSC::DivNurbsC(double L) const
{
	double dLEN = CalcNurbsCLength();					// NURBS曲線の線分長を得る
	double t_init = (m_V[1] - m_V[0])*L/dLEN;		// tの初期値をセット
	double t = CalcParamLengthOnNurbsC(L,t_init);	// 分割点パラメータ値取得

	NURBSC*	C1;
	NURBSC*	C2;
	boost::tie(C1,C2) = DivNurbsCParam(t);		// 分割

	return boost::make_tuple(C1,C2);
}

// Function: ConnectNurbsC
// 2本のNURBS曲線を連結する
//
// Parameter:
// *C1 - 曲線1
// *C2 - 曲線2
// *C_ - 連結後の曲線を格納
//
// Return:
// 成功：KOD_TRUE,  失敗：KOD_FALSE
NURBSC* NURBSC::ConnectNurbsC(const NURBSC* C2) const
{
	int flag = -1;		// 連結位置判別用フラグ
	NURBSC	C1_ = *this;
	NURBSC	C2_ = *C2;

	// 2曲線の連結位置を調べ，連結点がC1(1), C2(0)となるようどちらかの曲線を調整する
	if(m_vCp[0].DiffCoord(C2->m_vCp[0]) == KOD_TRUE){
		C1_.ReverseNurbsC();			// C1の向きを反転する
	}
	else if(m_vCp.front().DiffCoord(C2->m_vCp.back()) == KOD_TRUE){
		std::swap(C1_, C2_);
	}
	else if(m_vCp.back().DiffCoord(C2->m_vCp.front()) == KOD_TRUE){
		// このケースはOK．特に調整必要なし
	}
	else if(m_vCp.back().DiffCoord(C2->m_vCp.back()) == KOD_TRUE){
		C2_.ReverseNurbsC();			// C2の向きを反転する
	}
	else{
//		GuiIFB.SetMessage("NURBS_Func ERROR: Two Curves don't share the same coordinate value.");
		return NULL;
	}

	// 2曲線の階数が等しいこと
	if(m_M != C2->m_M){
//		GuiIFB.SetMessage("NURBS_Func ERROR: Two Curves don't have the same rank.");
		return NULL;
	}

	NURBSC* C_ = new NURBSC;
	// !!! 上記で調整したオブジェクトをベースに構築 !!!
	C1_.SetKnotVecC_ConnectC(&C2_, C_);		// C_のノット定義域を指定
	C1_.SetCPC_ConnectC(&C2_, C_);			// C_のコントロールポイントとウェイトを指定

	//for(int i=0;i<C_->N;i++)
	//	fprintf(stderr,"%d,%lf\n",i+1,C_->T[i]);
	//fprintf(stderr,"\n");
	//for(int i=0;i<C_->K;i++)
	//	fprintf(stderr,"%d,%lf,%lf,%lf,%lf\n",i+1,C_->cp[i].x,C_->cp[i].y,C_->cp[i].z,C_->W[i]);

	C_->m_M = m_M;							// C_の階数を指定

	C_->m_prop = m_prop;
	C_->m_EntUseFlag = m_EntUseFlag;
    C_->m_BlankStat = m_BlankStat;

	return C_;
}

/////////////////////////////////////////////////

// Function: ShiftNurbsC
// NURBS曲線のシフト
// 
// Parameters:
// *nurbs - 変更されるNURBS曲線  
// shift - シフト量
void NURBSC::ShiftNurbsC(const Coord& shift)
{
	for(size_t i=0;i<m_vCp.size();i++){
		m_vCp[i] += shift;
	}
}

// Function: ChRatioNurbsC
// NURBS曲線の倍率を変更する
//
// Parameters:
// *nurbs - 変更されるNURBS曲線  
// ratio - 倍率
void NURBSC::ChRatioNurbsC(const Coord& ratio)
{
	for(size_t i=0;i<m_vCp.size();i++){
		m_vCp[i] *= ratio;
	}
}

// Function: RotNurbsC
// NURBS曲面をDベクトル回りにdeg(°)だけ回転させる
//
// Parameters:
// *nurbs - 変更されるNURBS曲線　
// axis - 回転軸の単位ベクトル　
// deg - 角度(degree)
void NURBSC::RotNurbsC(const Coord& axis, double deg)
{
	double rad;			// ラジアン格納用
	QUATERNION QFunc;	// クォータニオン関連の関数を集めたクラスのオブジェクトを生成
	Quat StartQ;		// 回転前の座標を格納するクォータニオン
	Quat RotQ;			// 回転クォータニオン
	Quat ConjuQ;		// 共役クォータニオン
	Quat TargetQ;		// 回転後の座標を格納するクォータニオン
	
	for(size_t i=0;i<m_vCp.size();i++){		// コントロールポイント分ループ
		StartQ = QFunc.QInit(1,m_vCp[i].x,m_vCp[i].y,m_vCp[i].z);		// NURBS曲面を構成するcpの座標を登録
		rad = DegToRad(deg);									// degreeからradianに変換
		RotQ = QFunc.QGenRot(rad,axis.x,axis.y,axis.z);			// 回転クォータニオンに回転量を登録(ここの数字をいじれば任意に回転できる)
		ConjuQ = QFunc.QConjugation(RotQ);						// RotQの共役クォータニオンを登録
		TargetQ = QFunc.QMult(QFunc.QMult(RotQ,StartQ),ConjuQ);	// 回転させる
		m_vCp[i].SetCoord(TargetQ.x,TargetQ.y,TargetQ.z);	// 回転後の座標を登録
	}
}

// Function: ReverseNurbsC
// NURBS曲線のノットベクトル向きを反転する
//
// Parameters:
// *C - NURBS曲線 
void NURBSC::ReverseNurbsC(void)
{
	std::reverse(m_W.begin(),   m_W.end());
	std::reverse(m_vCp.begin(), m_vCp.end());
	std::reverse(m_T.begin(),   m_T.end());
	for(auto& TT : m_T) TT *= -1;
    ChangeKnotVecRange(m_T,m_M,m_vCp.size(),0,1);
}

// Function: DrawNurbsCurve
// NURBS曲線の描画
//
// Parameters:
// NurbsC - 描画するNURBS曲線構造体
void NURBSC::DrawNurbsCurve(void) const
{
	int i,j;
	static GLfloat	uKnot[KNOTNUMMAX];					// NURBS描画用バッファ
	static GLfloat	CCtlp[CTLPNUMMAX][4];				// NURBS描画用バッファ

	for(i=0;i<m_vCp.size();i++){			// コントロールポイント取り出し
		CCtlp[i][0] = m_vCp[i].x * m_W[i];
		CCtlp[i][1] = m_vCp[i].y * m_W[i];
		CCtlp[i][2] = m_vCp[i].z * m_W[i];
		CCtlp[i][3] = m_W[i];
	}

	for(j=0;j<m_T.size();j++){			// ノットベクトル取り出し
		uKnot[j] = m_T[j];
	}

	glDisable(GL_LIGHTING);
	gluBeginCurve(NurbsCurve);
	gluNurbsCurve(NurbsCurve,m_T.size(),uKnot,4,&CCtlp[0][0],m_M,GL_MAP1_VERTEX_4);		// ノットベクトルの値の範囲が0～1でないと、
	gluEndCurve(NurbsCurve);															// "ノット数がスプライン命令より多くありますと怒られる"
	glFlush();																			// ノットベクトルの正規化が必要(pp111)
	glEnable(GL_LIGHTING);

}

// Function: DrawNurbsCurve_Param
// 2DパラメトリックNURBS曲線要素の描画
//
// Parameters:
// *NurbsC - 描画する2DパラメトリックNURBS曲線のポインタ
void NURBSC::DrawNurbsCurve_Param(void) const
{
	int i;
	static GLfloat	uKnot[KNOTNUMMAX];					// NURBS描画用バッファ
	static GLfloat	CCtlp[CTLPNUMMAX][4];				// NURBS描画用バッファ

	for(i=0;i<m_vCp.size();i++){			// コントロールポイント取り出し
		CCtlp[i][0] = m_vCp[i].x * m_W[i];
		CCtlp[i][1] = m_vCp[i].y * m_W[i];
		CCtlp[i][2] = m_W[i];
	}
	for(i=0;i<m_T.size();i++){			// ノットベクトル取り出し
		uKnot[i] = m_T[i];
	}

	// トリム面を構成するNURBS曲線を指定
	gluNurbsCurve(NurbsSurf,m_T.size(),uKnot,4,&CCtlp[0][0],m_M,GLU_MAP1_TRIM_3);
}

/////////////////////////////////////////////////
// --- Private関数

// Function: GetNurbsCCoef
// (private)CalcIntersecCurve3()のサブ関数．NURBS曲線の係数を求める(最高3次)
// 
// Parameters:
// *nurb - 対象となるNURBS曲線 
// **coef - Bスプライン基底関数の係数 
// i - 曲線の番号 
// *P, *Q - NURBS曲線の係数(P,Q) 
//
// Return:
// 成功：KOD_TRUE, 失敗：KOD_ERR
boost::tuple<VCoord, Vdouble> NURBSC::GetNurbsCCoef(const ublasMatrix& coef, int i) const
{
	VCoord  P;
	Vdouble Q;
	for(int j=0;j<m_M;j++){
		double q = 0;
		Coord  p;
		for(int k=0;k<m_M;k++){
			q += coef(k,j)*m_W[i+k];
			p += m_vCp[i+k] * (coef(k,j)*m_W[i+k]);
		}
		Q.push_back(q);
		P.push_back(p);
	}
	
	return boost::make_tuple(P,Q);
}

// Function: InsertNewKnotOnNurbsC
// (private)NURBS曲線に新たなノットを挿入する
//
// Parameters:
// *C - 元のNURBS曲線  
// *C_ - 挿入対象のNURBS曲線     
// t - 挿入するノット     
// deg - 多重度
//
// Return:
// 新たなノットベクトル列におけるtの挿入位置
void NURBSC::InsertNewKnotOnNurbsC(double t, int deg, NURBSC* C_) const
{
	int CK = m_vCp.size();
	int k=0;					// tの挿入位置
	int m = m_M;				// 階数
	int n = CK;					// コントロールポイントの数

	Vdouble T_buf(CK+m_M+deg);	// ノットベクトル一時格納用バッファ
	VCoord cp_buf(CK+deg);		// コントロールポイント一時格納用バッファ
	Vdouble W_buf(CK+deg);		// ウェイト一時格納用バッファ

	// C_に元のNURBS曲線のT,cp,Wを初期値として代入
	C_->m_T.resize(m+n);
	for(int i=0;i<m+n;i++)
		C_->m_T[i] = m_T[i];
	for(int i=0;i<n;i++)
		C_->m_vCp.push_back(m_vCp[i]);
	C_->m_W.resize(n);
	for(int i=0;i<n;i++)
		C_->m_W[i] = m_W[i];

	// 多重度分，tの挿入を繰り返す
	for(int count=0;count<deg;count++){
		// 各bufにC_のT,cp,Wを代入
		for(int i=0;i<n+m;i++)
			T_buf[i] = C_->m_T[i];
		for(int i=0;i<n;i++)
			cp_buf[i] = C_->m_vCp[i];
		for(int i=0;i<n;i++)
			W_buf[i] = C_->m_W[i];

		// tの挿入位置kを調べる
		k=0;
		for(int i=0;i<n+m-1;i++){
			if(t >= T_buf[i] && t < T_buf[i+1]){
				k = i;
				break;
			}
		}

		// C_のノットベクトルを更新
		for(int i=0;i<=k;i++)
			C_->m_T[i] = T_buf[i];
		C_->m_T[k+1] = t;
		for(int i=k+2;i<=n+m;i++)
			C_->m_T[i] = T_buf[i-1];

		// コントロールポイントとウェイトの更新
		for(int i=0;i<=k-m+1;i++){
			C_->m_vCp[i] = cp_buf[i];
			C_->m_W[i]  = W_buf[i];
		}
		for(int i=k-m+2;i<=k;i++){
			double a = (t-T_buf[i])/(T_buf[i+m-1]-T_buf[i]);
			C_->m_vCp[i] = (cp_buf[i-1]*(1-a))+(cp_buf[i]*a);
			C_->m_W[i]  = (1-a)*W_buf[i-1] + a*W_buf[i];
		}
		for(int i=k+1;i<=n;i++){
			C_->m_vCp[i] = cp_buf[i-1];
			C_->m_W[i]  = W_buf[i-1];
		}

		n++;
	}
}

// Function: SetKnotVecC_ConnectC
// (private)2本の曲線を繋げたときのノットベクトルを設定する
// 
// Parameters:
// *C1, *Cs - 連結する2つのNURBS曲線
// *C_ - 連結後のNURBS曲線
void NURBSC::SetKnotVecC_ConnectC(const NURBSC* C2, NURBSC* C_) const
{
	// コード長を調べる
	double s=0,e=NORM_KNOT_VAL,c=0;			// 開始，終了，連結部ノットベクトル
	double l1=0,l2=0;						// 各曲線のノットベクトルのコード長
	for(int i=0;i<m_T.size()-1;i++)
		l1 += CalcNurbsCCoord(m_T[i+1]).CalcDistance(CalcNurbsCCoord(m_T[i]));	// C1のコード長
	for(int i=0;i<C2->m_T.size()-1;i++)
		l2 += C2->CalcNurbsCCoord(C2->m_T[i+1]).CalcDistance(C2->CalcNurbsCCoord(C2->m_T[i]));	// C2のコード長
	c = l1/(l1+l2);	// 結合点のノットベクトル値

	// C_のノットベクトル範囲を得る
	ublasVector T1 = ChangeKnotVecRange(    m_T,    m_M,    m_vCp.size(),s,c);	// C1のノットベクトルの範囲を変更
	ublasVector T2 = ChangeKnotVecRange(C2->m_T,C2->m_M,C2->m_vCp.size(),c,e);	// C2(U2)のノットベクトルの範囲を変更
	C_->m_V[0] = s;						// C_のノットベクトルの範囲
	C_->m_V[1] = e;
	C_->m_T.resize(m_T.size() + C2->m_T.size() - C2->m_M - 1);	// C_のノットベクトル数

	// C_のノットベクトルを得る
	for(int i=0;i<m_vCp.size();i++)
		C_->m_T[i] = T1[i];
	for(int i=1;i<C2->m_T.size();i++)
		C_->m_T[m_vCp.size()+i-1] = T2[i];
}

// Function: SetCPC_ConnectC
// (private)2本の曲線を繋げたときのコントロールポイントとウェイトを設定する
// 
// Parameters:
// *C1, *C2 - 連結する2つのNURBS曲線
// *C_ - 連結後のNURBS曲線
void NURBSC::SetCPC_ConnectC(const NURBSC* C2, NURBSC* C_) const
{
	int K[] = {m_vCp.size(), C2->m_vCp.size()};

	C_->m_vCp.clear();
	C_->m_W.resize(K[0] + K[1] - 1);

	for(int i=0;i<K[0];i++){
		C_->m_vCp.push_back(m_vCp[i]);
		C_->m_W[i] = m_W[i];
	}
	for(int i=1;i<K[1];i++){
		C_->m_vCp.push_back(C2->m_vCp[i]);
		C_->m_W[K[0]+i-1] = C2->m_W[i];
	}
}

/////////////////////////////////////////////////
// --- Debug関数

// Function: DebugForNurbsC
// NURBS曲線情報をデバッグプリント
//
// Parameters:
// *nurbs - デバッグするNURBS曲線
void NURBSC::DebugForNurbsC(void) const
{
	int K = m_vCp.size();
	fprintf(stderr,"Cp num: %d\n",K);
	fprintf(stderr,"Rank: %d\n",m_M);
	fprintf(stderr,"Knot num: %d\n",m_T.size());
	fprintf(stderr,"Knot range: %lf - %lf\n",m_V[0], m_V[1]);

	// コントロールポイント
	fprintf(stderr,"Control Point\n");
	for(int i=0;i<K;i++){
		fprintf(stderr,"#%d: (%lf,%lf,%lf)\t",i+1,m_vCp[i].x,m_vCp[i].y,m_vCp[i].z);
	}
	fprintf(stderr,"\n");

	// ノットシーケンス
	fprintf(stderr,"Knot Vector\t");
	for(int i=0;i<K+m_M;i++){
		fprintf(stderr,"#%d: %lf\t",i+1,m_T[i]);
	}
	fprintf(stderr,"\n");

	// ウェイト
	fprintf(stderr,"Weight\n");
	for(int i=0;i<K;i++){
		fprintf(stderr,"#%d: %lf\t",i+1,m_W[i]);
	}
}
