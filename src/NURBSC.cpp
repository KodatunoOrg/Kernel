#include "KodatunoKernel.h"
#include "NURBS.h"

///////////////////////////////////////////////////////////
// コンストラクタ

NURBSC::NURBSC()
{
    K = 0;
	M = 0;
	N = 0;
	prop[0] = prop[1] = prop[2] = prop[3] = 0;
	V[0] = V[1] = 0;
	BlankStat = 0;
	EntUseFlag = 0;
	pD = 0;
	OriginEnt = 0;
	pOriginEnt = NULL;
}

NURBSC::NURBSC(int K,int M,int N,const ublasVector& T, const ublasVector& W, const ACoord& cp, const A2double& V, const A4int& prop, int euflag)
{
	this->K = K;
	this->M = M;
	this->N = N;
	this->V = V;
	this->EntUseFlag = euflag;
   	this->BlankStat = 0;     // DISPLAY:デフォルトで描画要素に設定
	this->prop = prop;
	this->T = T;		// resize()必要なし．要素数が代入元に合わさる
	this->W = W;
	this->cp.resize(boost::extents[K]);
	this->cp = cp;		// resize()しないと，単純代入はASSERTエラー
	this->Dstat.Color[0] = this->Dstat.Color[1] = this->Dstat.Color[2] = 1.0;
	this->Dstat.Color[3] = 0.5;
	this->pD = 0;
	this->OriginEnt = 0;
	this->pOriginEnt = NULL;
}

NURBSC::NURBSC(const NURBSC* nurb)
{
	this->K = nurb->K;
	this->M = nurb->M;
	this->N = nurb->N;
	this->V = nurb->V;
	this->T = nurb->T;
	this->W = nurb->W;
	this->cp.resize(boost::extents[nurb->K]);
	this->cp = nurb->cp;
    this->BlankStat = nurb->BlankStat;
   	this->EntUseFlag = nurb->EntUseFlag;
	this->pD = 0;
	this->OriginEnt = 0;
	this->pOriginEnt = NULL;
}

///////////////////////////////////////////////////////////
// メンバ関数

// Function: CalcNurbsCCoord
// 指定したノットtでのNURBS曲線の座標値を求める
//
// Parameters:
// *NurbsC - 対象とするNURBS曲線へのポインタ
// t - ノット値
//
// Return:
// 座標値
Coord NURBSC::CalcNurbsCCoord(double t) const
{
	Coord p;
	Coord bscpw;
	double bsw=0;
	double bs=0;
	int i;

	for(i=0;i<K;i++){
		bs = CalcBSbasis(t,T,i,M);	    // Bスプライン基底関数を求める
		bsw += bs*W[i];					// 分母
		bscpw += cp[i] * (bs*W[i]);		// 分子
	}
	
	p = bscpw / bsw;	// 座標値を求める

	return p;
}

// Function: CalcNurbsCCoords
// 指定したノットt群でのNURBS曲線の座標値を求める
//
// Parameters:
// *NurbsS - NURBS曲面へのポインタ   
// Ptnum - 求める点群の数   
// *T - tパラメータ群を格納した配列
// *Pt - 実座標値を格納
VCoord NURBSC::CalcNurbsCCoords(const Vdouble& V) const
{
	VCoord Pt;
	BOOST_FOREACH(double t, V) {
		Pt.push_back(CalcNurbsCCoord(t));
	}
	return Pt;
}

// Function: GenRotNurbsS
// NurbsCを原点を通るAxis回りにdegだけ回転させた回転サーフェスNurbsSを生成する
//
// Parameter:
// *NurbsS - 生成される回転サーフェス(NURBS曲面)へのポインタ
// NurbsC - 基線となるNURBS曲線
// Axis - 回転軸ベクトル
// deg - 回転角度（deg)
//
// Return:
// 成功：KOD_TRUE, 失敗：KOD_ERR
NURBSS* NURBSC::GenRotNurbsS(const Coord& a, double deg) const
{
	NURBSS* NurbsS = NULL;
	Coord Axis = a.NormalizeVec();		// 正規化

    // 回転角度によって，いくつのセグメントで円弧を生成するか判断する
    // 回転角度が180度未満の場合，1セグメントで円弧を表現する
    if(fabs(deg) < 180 ){
        ublasVector S(6);	// u方向ノットベクトル
		S[0]=0; S[1]=0; S[2]=0; S[3]=1; S[4]=1; S[5]=1;
        ublasMatrix W(3,K);	// ウエイト
        AACoord Cp(boost::extents[3][K]);	// コントロールポイント
        double rad = DegToRad(deg);
        for(int i=0;i<3;i++){
            for(int j=0;j<K;j++){
                Coord Q_  = cp[j].CalcRotVec(Axis,(double)i*rad/2);	// 元々のNURBS曲線上のコントロールポイントをAxis周りに0,deg/2,deg度回転
                Coord P   = cp[j].CalcNormalLine(Coord(),Axis);		// Axis上の回転中心の座標
                Coord PQ_ = Q_ - P;	// PQ_ベクトルを生成
                if(i%2 == 0){		// i=0,2のとき
                    W(i,j) = this->W[j];
                    Cp[i][j] = Q_;
                }
                else{
                    W(i,j) = this->W[j]*cos(rad/2);
                    Cp[i][j] = PQ_ * 1/cos(rad/2) + P;
                }
            }
        }
        NurbsS = new NURBSS(3,M,3,K,S,T,W,Cp,0,1,0,1);		// NURBS曲面生成
    }

    // 回転角度が270未満の場合，2セグメントで円弧を表現する
    else if(fabs(deg) < 270){
        ublasVector S(8);
		S[0]=0; S[1]=0; S[2]=0; S[3]=0.5; S[4]=0.5; S[5]=1; S[6]=1; S[7]=1;
        ublasMatrix W(5,K);	// ウエイト
        AACoord Cp(boost::extents[5][K]);	// コントロールポイント
        double rad = DegToRad(deg);
        for(int i=0;i<5;i++){
            for(int j=0;j<K;j++){
                Coord Q_  = cp[j].CalcRotVec(Axis,(double)i*rad/4);	// 元々のNURBS曲線上のコントロールポイントをAxis周りに0,deg/2,deg度回転
                Coord P   = cp[j].CalcNormalLine(Coord(),Axis);		// Axis上の回転中心の座標
                Coord PQ_ = Q_ - P;	// PQ_ベクトルを生成
                if(i%2 ==  1){	// i=1,3のとき
                    W(i,j) = this->W[j]*cos(rad/4);
                    Cp[i][j] = PQ_ * 1/cos(rad/4) + P;
                }
                else{		// i=0,2,4のとき
                    W(i,j) = this->W[j];
                    Cp[i][j] = Q_;
                }
            }
        }
        NurbsS = new NURBSS(3,M,5,K,S,T,W,Cp,0,1,0,1);		// NURBS曲面生成
    }

    // 回転角度が360度未満の場合，3セグメントで円弧を表現する
    else if(fabs(deg) < 360){
        ublasVector S(10);
		S[0]=0; S[1]=0; S[2]=0; S[3]=0.33; S[4]=0.33; S[5]=0.66; S[6]=0.66; S[7]=1; S[8]=1; S[9]=1;
        ublasMatrix W(7,K);	// ウエイト
        AACoord Cp(boost::extents[7][K]);	// コントロールポイント
        double rad = DegToRad(deg);
        for(int i=0;i<7;i++){
            for(int j=0;j<K;j++){
                Coord Q_  = cp[j].CalcRotVec(Axis,(double)i*rad/6);		// 元々のNURBS曲線上のコントロールポイントをAxis周りに0,deg/2,deg度回転
                Coord P   = cp[j].CalcNormalLine(Coord(),Axis);	// Axis上の回転中心の座標
                Coord PQ_ = Q_ - P;	// PQ_ベクトルを生成
                if(i%2 ==  0){	// i=0,2,4,6のとき
                    W(i,j) = this->W[j];
                    Cp[i][j] = Q_;
                }
                else{		// i=1,3,5のとき
                    W(i,j) = this->W[j]*cos(rad/6);
                    Cp[i][j] = PQ_ * 1/cos(rad/6) + P;
                }
            }
        }
        NurbsS = new NURBSS(3,M,7,K,S,T,W,Cp,0,1,0,1);		// NURBS曲面生成
        NurbsS->DebugForNurbsS();
    }
    // 360度以上
    else{
        // NurbsSを生成
        ublasVector S(12);	// u方向ノットベクトル
		S[0]=0; S[1]=0; S[2]=0; S[3]=0.25; S[4]=0.25; S[5]=0.5; S[6]=0.5; S[7]=0.75; S[8]=0.75; S[9]=1; S[10]=1; S[11]=1;
        ublasMatrix W(9,K);			// ウエイト
        AACoord Cp(boost::extents[9][K]);		// コントロールポイント
        for(int i=0;i<9;i++){		// u方向
            for(int j=0;j<K;j++){		// v方向
                Coord Q_  = cp[j].CalcRotVec(Axis,(double)i*PI/4);		// 元々のNURBS曲線上のコントロールポイントをAxis周りに45度回転
                Coord P   = cp[j].CalcNormalLine(Coord(),Axis);			// Axis上の回転中心の座標
                Coord PQ_ = Q_ - P;												// PQ_ベクトルを生成
                if(i%2 == 0){													// i=0,2,4,6のとき
                    W(i,j) = this->W[j];										// ウエイト
                    Cp[i][j] = Q_;												// Q_がそのままコントロールポイントになる
                }
                else{															// i=1,3,5,7のとき
                    W(i,j) = this->W[j]*cos(PI/4);							// ウエイト計算
                    Cp[i][j] = PQ_ * 1/cos(PI/4) + P;							// コントロールポイント計算
                }
            }
        }
        NurbsS = new NURBSS(3,M,9,K,S,T,W,Cp,0,1,0,1);		// NURBS曲面生成
    }

    return NurbsS;
}

// Function: GenSweepNurbsS
// 1つのNURBS曲線からある軸方向にある距離だけスイープさせたスイープサーフェスを生成する
//
// Parameters:
// *NurbsS - 生成されるスイープサーフェス(NURBS曲面)へのポインタ
// NurbsC - 基線となるNURBS曲線
// Axis - スイープ方向ベクトル
// Len - スイープ距離
//
// Return:
// 成功：KOD_TRUE, 失敗：KOD_ERR
NURBSS* NURBSC::GenSweepNurbsS(const Coord& a, double Len) const
{
	Coord Axis = a.NormalizeVec();		// 正規化

	// NurbsSを生成
	ublasVector T(4);	// v方向ノットベクトル
	T[0]=0; T[1]=0; T[2]=1; T[3]=1;
	ublasMatrix W(K,2);		// ウエイト
	AACoord Cp(boost::extents[K][2]);		// コントロールポイント

	for(int i=0;i<K;i++){
		for(int j=0;j<2;j++){
			W(i,j) = this->W[i];	// ウエイト計算
			if(j==0)
				Cp[i][j] = cp[i];		// コントロールポイント計算
			else
				Cp[i][j] = cp[i] + (Axis * Len);		// コントロールポイント計算
		}
	}

	return new NURBSS(M,2,K,2,T,T,W,Cp,0,1,V[0],V[1]);	// NURBS曲面生成
}

// Fucntion:CalcDiffNurbsC
// NURBS曲線の1階微分係数を求める
// 
// Paramters:
// *NurbsC - NURBS曲線へのポインタ
// t - ノット値
//
// Return:
// 計算結果
Coord NURBSC::CalcDiffNurbsC(double t) const
{
	Coord Ft,diff_Ft;		// NURBS曲線の分子
	double Gt,diff_Gt;		// NURBS曲線の分母
	double bs,diff_bs;		// Bスプライン基底関数
//	Coord p;
	int i;

	Gt = 0;
	diff_Gt = 0;

	// 各係数算出
	for(i=0;i<K;i++){
		bs = CalcBSbasis(t,T,i,M);
		diff_bs = CalcDiffBSbasis(t,T,i,M);

		Ft += cp[i] * (bs*W[i]);
		diff_Ft += cp[i] * (diff_bs*W[i]);

		Gt += bs*W[i];
		diff_Gt += diff_bs*W[i];
	}
	if(fabs(Gt) < APPROX_ZERO)	return(Coord());

	// 1階微分を求める
//	p = SubCoord(DivCoord(diff_Ft,Gt),DivCoord(MulCoord(Ft,diff_Gt),Gt*Gt));
	return (diff_Ft / Gt) - ((Ft*diff_Gt)/(Gt*Gt));
}

// Function: CalcDiff2NurbsC
// NURBS曲線の2階微分係数を求める
// 
// Paramters:
// *NurbsC - NURBS曲線へのポインタ
// t - ノット値
//
// Return:
// 計算結果
Coord NURBSC::CalcDiff2NurbsC(double t) const
{
	double w0=0;
	double w1=0;
	double w2=0;
	Coord  A2;
	Coord  P0;
	Coord  P1;

	P0 = CalcNurbsCCoord(t);
	P1 = CalcDiffNurbsC(t);

	for(int i=0;i<K;i++){
		w0 += CalcBSbasis(t,T,i,M) * W[i];
		w1 += CalcDiffBSbasis(t,T,i,M) * W[i];
		w2 += CalcDiffBSbasisN(t,T,i,M,2) * W[i];
		A2 += cp[i] * (CalcDiffBSbasisN(t,T,i,M,2) * W[i]);
	}

//	return DivCoord(SubCoord(A2,AddCoord(MulCoord(P1,2*w1),MulCoord(P0,2*w2))),w0);
	return (A2-((P1*2*w1)+(P0*2*w2)))/w0;
}

// Function: CalcDiffNNurbsC
// NURBS曲線のr階微分係数を求める
// 
// Paramters:
// *NurbsC - NURBS曲線へのポインタ
// r - 微分階数
// t - ノット値
//
// Return:
// 計算結果
Coord NURBSC::CalcDiffNNurbsC(int r, double t) const
{
	if(!r)
		return CalcNurbsCCoord(t);

	Coord Ar;
	double W = 0;

	for(int i=0;i<K;i++){
		double bsr = CalcDiffBSbasisN(t,T,i,M,r);
		Ar += cp[i] * (bsr*this->W[i]);
		W  += this->W[i]*CalcBSbasis(t,T,i,M);
	}

	Coord Br;
	for(int i=1;i<=r;i++){
		double Wi = 0;
		for(int j=0;j<K;j++){
			double bsi = CalcDiffBSbasisN(t,T,j,M,i);
			Wi += bsi*this->W[j];
		}
		if(Wi == 0.0)  return(Coord());
//		Br = AddCoord(Br,MulCoord(CalcDiffNNurbsC(r-i,t),(double)nCr(r,i)*Wi));	// 回帰
		Br += CalcDiffNNurbsC(r-i,t) * ((double)nCr(r,i)*Wi);	// 回帰
	}

//	return (DivCoord(SubCoord(Ar,Br),W));
	return (Ar-Br)/W;
}

// Function: CalcIntersecPtNurbsPt
// 空間上の1点PからNURBS曲線C上の最近傍点Q(曲線パラメータ)を求める(ニュートン法)
// 
// >F(t) = (P-C'(t))･C'(t) = 0
// >F'(t)dt = -F(t)
// >F'(t) = -|C'(t)|^2 + (P+C(t))･C"(t)
//
// Parameters:
// *C - NURBS曲線
// P - 空間上の1点
// Divnum - ニュートン法初期値指定用の曲線分割数
// LoD - ニュートンパラメータ更新時のステップサイズ(1～)
// Q - 解（C上の点をtパラメータで格納）
// 
// Return:
// KOD_TRUE：収束した    KOD_FALSE:収束しなかった
int NURBSC::CalcIntersecPtNurbsPt(const Coord& P, int Divnum, int LoD, double *Q) const
{
	ublasVector t_buf(Divnum);					// 収束解格納用バッファ
	ublasVector dist_buf(Divnum);				// 各tでの距離格納用バッファ
	double delta = (V[1] - V[0])/(double)Divnum;	// 収束演算用のtパラメータのインターバル値

	for(int i=0;i<Divnum;i++){
		double t = V[0] + (double)i*delta;	// tの初期値をセット
		int loopcount = 0;
		while(loopcount < LOOPCOUNTMAX){
			Coord Ct = CalcNurbsCCoord(t);
			Coord C_ = CalcDiffNurbsC(t);
			Coord C__ = CalcDiff2NurbsC(t);
			double a = P  & C_;
			double b = Ct & C_;
			double c = C_ & C_;
			double d = (P-Ct) & C__;
			if(fabs(d-c) <= APPROX_ZERO)	break;			// 分母がゼロなら次の初期点へ
			double dt = (b-a)/(d-c);
			t += dt/(double)LoD;				// t更新
			if(fabs(dt) <= APPROX_ZERO_L){	// 収束していたら解を保持し次のtへ
				t_buf[i] = t;
				dist_buf[i] = CalcNurbsCCoord(t).CalcDistance(P);	// PQ間距離を得る
				break;
			}
			loopcount++;
			t_buf[i] = dist_buf[i] = -1;		// 収束していなかったら，エラーフラグとして-1を代入
		}
	}

	// 得られた解から，PQ間の距離が最も短いものを選択
	bool flag = false;
	double min = 1E+308;
	for(int i=0;i<Divnum;i++){
		if(dist_buf[i] > 0 && dist_buf[i] < min){
			min = dist_buf[i];
			*Q = t_buf[i];
			flag = true;
		}
	}
	
	return flag == true ? KOD_TRUE : KOD_FALSE;
}

// Function: CalcIntersecPtNurbsPtDescrete
// 空間上の1点PからNURBS曲線C上の最近傍点Qを求める(離散的)
//
// Parameters:
// *C - NURBS曲線
// P - 空間上の1点
// Divnum - 曲面分割数
// LoD - 詳細度
// Ts - t方向パラメータの探索開始値
// Te - t方向パラメータの探索終了値
// *Q - 解（C上の点をtパラメータで格納）
void NURBSC::CalcIntersecPtNurbsPtDescrete(const Coord& P, int Divnum, int LoD, double Ts, double Te, double *Q) const
{
    if(!LoD)    return;

    double mind = 1E+38;
    Coord minp;
    double dt = (Te-Ts)/(double)Divnum;

    for(int i=0;i<=Divnum;i++){
        double t = Ts + (double)i*dt;
        if(t < V[0] || t > V[1]) continue;
        Coord p  = CalcNurbsCCoord(t);
        double d = p.CalcDistance(P);
        if(d < mind){
            mind = d;
            *Q = t;
        }
    }

    CalcIntersecPtNurbsPtDescrete(P,Divnum,LoD-1,*Q-dt,*Q+dt,Q);
}

// Function: CalcIntersecCurve
// NURBS曲線と平面との交点を求める(ニュートン法)
// F(t) = nvec・(C(t)-pt) = 0をニュートン法を用いて求める．
// 交点は最大で(M-1)*(K-M+1)点得られる.  (例：4階でコントロールポイントの数8個の場合、(4-1)*(8-4+1)=15点)．
// よって引数*ansは(M-1)*(K-M+1)個の配列を用意することが望ましい.
//
// Parameters:
// *nurb - NURBS曲線  
// pt - 平面上の一点  
// nvec - 平面の法線ベクトル   
// Divnum - NURBS曲線のパラメータ分割数  
// *ans - 算出された交点のtパラメータ値を格納
// ans_size - ansの配列長
// LoD - 詳細度（ニュートン法の更新パラメータを足しこむときに，LoDで割ることで，急激なパラメータ変更を避ける．通常は1でよいが，解が得られない場合は値を大きくする．2とか3とか）
//
// Return:
// 交点の個数（KOD_ERR：交点の数がans_sizeを超えた）
int NURBSC::CalcIntersecCurve(const Coord& pt, const Coord& nvec, int Divnum, ublasVector& ans, int ans_size, int LoD) const
{
	double t = V[0];		// 現在のNURBS曲線のパラメータ値
	double d = 0;				// ニュートン法によるパラメータの更新量
	double F;					// ニュートン法の対象とする方程式
	double Ft;					// Fのtによる微分値
	double dt = (V[1] - V[0])/(double)Divnum;	// 初期点の増分値
	int loopcount = 0;			// ループ回数
	bool flag = false;			// 収束フラグ
	int anscount = 0;			// 交点の数をカウント

	if(!LoD){
//		GuiIFB.SetMessage("NURBS_Func ERROR: LoD is changed 0 to 1");
		LoD = 1;
	}

	for(int i=0;i<=Divnum;i++){
		flag = false;
		loopcount = 0;
		t = V[0] + (double)i*dt;		// 初期値更新
		while(loopcount < LOOPCOUNTMAX){
			F  = nvec & (CalcNurbsCCoord(t)-pt);
			Ft = nvec &  CalcDiffNurbsC(t);
			d = -F/Ft;		// 更新値
			//fprintf(stderr,"   %d:%.14lf,%lf\n",i,d,t);	// for debug
			if(CheckZero(d,HIGH_ACCURACY) == KOD_TRUE){		// 更新値が閾値以下になったら、whileを抜け、解として登録
				flag = true;
				break;
			}
			t += d/(double)LoD;		// パラメータ値更新
			
			if(t < V[0] || t > V[1]){		// パラメータ範囲を超えたら、whileを抜け、次の初期値へ移行
				flag = false;
				break;
			}
			loopcount++;
		}// end of wihle
		if(flag == true){
			if(anscount == ans_size){	// 解の個数がans_sizeを超えたら、ERRをリターン
//				GuiIFB.SetMessage("NURBS_Func ERROR: Ans_size overflow");
				return KOD_ERR;
			}
			ans[anscount] = t;		// 解として登録
			anscount++;
		}
	}// end of i loop

	anscount = CheckTheSamePoints(ans,anscount);		// 同一点は除去する

	return anscount;
}

// Function: CalcIntersecCurve3 
// NURBS曲線と平面との交点を求める(3次まで対応)
// 交点は最大で(M-1)*(K-M+1)点得られる.  (例：4階でコントロールポイントの数8個の場合、(4-1)*(8-4+1)=15点)
// よって引数*ansは(M-1)*(K-M+1)個の配列を用意することが望ましい.
// 
// Parameters:
// *nurb - NURBS曲線  
// pt - 平面上の一点  
// nvec - 平面の法線ベクトル  
// *ans - 算出された交点のtパラメータ値を格納
// ans_size - ansの配列長
//
// Return:
// 交点の個数（曲線次数が3次以上：KOD_ERR）
int NURBSC::CalcIntersecCurve3(const Coord& pt, const Coord& nvec, double *ans, int ans_size) const
{
	ublasMatrix coef(M,M);
	ublasVector Q(4);	// NURBS曲線の分母の係数
	ACoord  P(boost::extents[4]);		// NURBS曲線の分子の係数
	ublasVector a(4);
	ublasVector t(3);
	int ansnum;
	int k=0;

	// 1本のNURBS曲線はK-M+1本の曲線から構成される。それぞれの構成曲線に対して方程式を導出し、解を得る。
	for(int i=0;i<K-M+1;i++){
		if(M-1 == 3){			// 3次			
			GetBSplCoef3(M,K,i,T,coef);	// 各コントロールポイントにおける3次Bスプライン基底関数の係数(coef)を求める
		}
		else if(M-1 == 2){	// 2次
			GetBSplCoef2(M,K,i,T,coef);	// 各コントロールポイントにおける2次Bスプライン基底関数の係数を求める
		}
		else if(M-1 == 1){	// 1次	
			GetBSplCoef1(M,K,i,T,coef);	// 各コントロールポイントにおける1次Bスプライン基底関数の係数を求める
		}
		else{
//			char mes[256];
//			sprintf(mes,"NURBS KOD_ERROR:Ther order of equation is unsupported. (order = %d)",M-1);
//			GuiIFB.SetMessage(mes);
			goto EXIT;
		}
		GetNurbsCCoef(coef,i,P,Q);						// NURBS曲線の係数(P,Q)を求める
		GetIntersecEquation(M,P,Q,pt,nvec,a);			// NURBS曲線と平面の交線導出用方程式を得る
		ansnum = CalcEquation(a,t,M-1);					// 方程式を解き、交点のパラメータ値を得る

		for(int j=0;j<ansnum;j++){
			if(t[j] >= T[i+M-1] && t[j] <= T[i+M]){	// ノットベクトルの値と適合するもののみ解として抽出
				if(k == ans_size){
//					GuiIFB.SetMessage("NURBS KOD_ERROR:Intersection points exceeded the allocated array length");
					goto EXIT;
				}
				ans[k] = t[j];		// 解を取得
				k++;				// 解の数をインクリメント
			}
		}
	}

	return k;

EXIT:
	return KOD_ERR;
}

// Function: CalcIntersecPtsNurbsCNurbsCParam
// (x,y)平面上のNURBS曲線同士の交点を求める(ニュートン法)
// 
// Parameters:
// *NurbA, *NurbB - NURBS曲線
// Divnum - 初期値設定用の分割数     
// *ans - 交点格納用配列   
// ans_size - ansの配列長
// 
// Return:
// 解の個数（ans_sizeを超えたら，KOD_ERR）
VCoord NURBSC::CalcIntersecPtsNurbsCNurbsCParam(const NURBSC* NurbB, int Divnum) const
{
	VCoord ans;
	double t = V[0];		// 現在のNurbAのパラメータ値
	double u = 0;				// 現在のNurbBのパラメータ値
	double dt = 0;				// ニュートン法によるtパラメータの更新量
	double du = 0;				// ニュートン法によるuパラメータの更新量
	Coord F;					// ニュートン法の対象とする方程式(F(t,u) = NurbA(t) - NurbB(u))
	Coord Ft;					// Fのtによる微分値
	Coord Fu;					// Fのuによる微分値
	double d = (V[1] - V[0])/(double)Divnum;	// 初期点の増分値
	int loopcount = 0;			// ループ回数
	bool flag = false;			// 収束フラグ
	int anscount = 0;			// 交点の数をカウント
	ublasMatrix A(2,2);			// Ft,Fuを成分ごとに格納した行列
	ublasMatrix A_(2,2);		// Aの逆行列を格納
	

	for(int i=0;i<Divnum;i++){
		flag = false;
		loopcount = 0;
		t =        V[0] + (double)i*d;		// 初期値更新
        u = NurbB->V[0];
		while(loopcount < LOOPCOUNTMAX){
			F  =        CalcNurbsCCoord(t) - NurbB->CalcNurbsCCoord(u);
			Ft =        CalcDiffNurbsC(t);
			Fu = NurbB->CalcDiffNurbsC(u);
			A(0,0) = Ft.x;
            A(0,1) = -Fu.x;
			A(1,0) = Ft.y;
            A(1,1) = -Fu.y;
			MatInv2(A,A_);
			dt = -(A_(0,0)*F.x + A_(0,1)*F.y);
			du = -(A_(1,0)*F.x + A_(1,1)*F.y);

			if(CheckZero(dt,HIGH_ACCURACY) == KOD_TRUE && CheckZero(du,HIGH_ACCURACY) == KOD_TRUE){		// 更新値が閾値以下になったら、whileを抜け、解として登録
				flag = true;
				break;
			}
            t += dt/3;		// パラメータ値更新
            u += du/3;
			if(t < V[0] || t > V[1] || u < NurbB->V[0] || u > NurbB->V[1]){		// パラメータ範囲を超えたら、whileを抜け、次の初期値へ移行
				flag = false;
				break;
			}
			loopcount++;
		}// end of wihle
		if(flag == true){
			Coord cp(t, u, 0);
			if ( !IsCheckTheSamePoints(ans, cp) ) {
				ans.push_back(cp);		// 解として登録
			}
		}
	}// end of i loop

	return ans;
}

// Function: ClacIntersecPtsNurbsCLine
// 2次元NURBS曲線と直線との交点を求める
//
// Parameters:
// *C - NURBS曲線
// P - 直線上の1点
// r - 直線の方向ベクトル
// *t1 - 交点におけるNURBS曲線パラメータ
// *t2 - 交点における直線パラメータ
//
// return:
// 交点の有無（KOD_TRUE：交点あり， KOD_FALSE：交点なし）
int NURBSC::ClacIntersecPtsNurbsCLine(const Coord& P, const Coord& r, double* t1, double* t2) const
{
    ublasMatrix A(2,2);
    ublasMatrix A_(2,2);
    bool conv_flag = false;

    *t1 = (V[0]+V[1])/2;
    *t2 = 0;

    while(1){
        Coord Ct = CalcDiffNurbsC(*t1);
        Coord Lt = r;
        Coord B = (P+(r*(*t2))) - CalcNurbsCCoord(*t1);
        A(0,0) = Ct.x;
        A(1,0) = Ct.y;
        A(0,1) = -Lt.x;
        A(1,1) = -Lt.y;
        double det = MatInv2(A,A_);
        if(det == 0) break;
        double dt1 = A_(0,0)*B.x + A_(0,1)*B.y;
        double dt2 = A_(1,0)*B.x + A_(1,1)*B.y;
        //fprintf(stderr,"    %lf,%lf,%lf,%lf,%lf\n",*t1,*t2,dt1,dt2,det);		// fro debug
        if(CheckZero(dt1,LOW_ACCURACY) == KOD_TRUE && CheckZero(dt2,LOW_ACCURACY) == KOD_TRUE){		// 交点に収束したらwhile break
            conv_flag = true;
            break;
        }
        else{
            *t1 += dt1/3;
            *t2 += dt2/3;
        }
        if(*t1 < V[0] || *t1 > V[1])	// 現在注目中のエッジの範囲を超えたらbreak
            break;
    }

    if(conv_flag == true)
        return KOD_TRUE;
    else
        return KOD_ERR;
}

// Function: ClacIntersecPtsNurbsCLineSeg
// 2次元NURBS曲線と線分との交点を求める
//
// Parameters:
// *C - NURBS曲線
// P - 線分上の1点
// r - 線分の方向ベクトル
// ts - 線分の始点パラメータ
// te - 線分の終点パラメータ
// *t1 - 交点におけるNURBS曲線パラメータ
// *t2 - 交点における直線パラメータ
//
// return:
// 交点の有無（KOD_TRUE：交点あり， KOD_FALSE：交点なし）
int NURBSC::ClacIntersecPtsNurbsCLineSeg(const Coord& P, const Coord& r, double ts, double te, double* t1, double* t2) const
{
    if(ClacIntersecPtsNurbsCLine(P,r,t1,t2) == KOD_TRUE){
        if(*t2 >= ts && *t2 <= te){
            return KOD_TRUE;
        }
        else{
            return KOD_FALSE;
        }
    }

    return KOD_FALSE;
}

// Function: CalcDeltaPtsOnNurbsC
// 指定した分割数でNURBS曲線上の座標値を出力する
// 
// Parameters:
// *Nurb - NURBSへのポインタ  
// D - 分割数  
// *Pts - 出力される座標値を格納
//
// Return:
// 点数
int NURBSC::CalcDeltaPtsOnNurbsC(int D, ACoord& Pts) const
{
	double T = (V[1] - V[0])/D;	// パラメトリック空間内での線分長を得る

	for(int i=0;i<=D;i++){
		Pts[i] = CalcNurbsCCoord(V[0] + T*(double)i);
	}

    return D+1;
}

// Function: CalcExtremumNurbsC
// NURBS曲線の指定した方向における極値の座標値を得る
//
// Parameters:
// *C - 極値座標を求めたいNURBS曲線へのポインタ   
// nf - 方向ベクトル     
// *pt - 得られた極値のNurbs曲線パラメータ値列    
// ptnum - *ptの配列長
//
// Return:
// 得られた極値パラメータの数（KOD_FALSE:得られなかった, KOD_ERR:極値パラメータの数がptnumを超えた）
int NURBSC::CalcExtremumNurbsC(const Coord& nf, ublasVector& pt, int ptnum) const
{
	int anscount=0;			// 極値の数

	// NURBS曲線のパラメータ区間をCONVDIVNUMで区切り、それぞれに対してニュートン法による収束計算を行う
	for(int i=0;i<=CONVDIVNUM;i++){
		double t = V[0] + (V[1] - V[0])/CONVDIVNUM*(double)i;	// 探索開始パラメータ値
		double dt=0;					// ニュートン法用の増分値
		int lpcount=0;					// 収束計算回数
		bool flag = false;				// 例外フラグ

		// 収束計算
		while(lpcount < LOOPCOUNTMAX){
			double f_  = nf & CalcDiffNurbsC(t);
			double f__ = nf & CalcDiff2NurbsC(t);
			if(f__ == 0.0)	break;
			dt = f_/f__;

			if(CheckZero(dt,MID_ACCURACY)){			// 収束した
				flag = true;
				break;
			}
			t -= dt;	// ニュートンパラメータ更新
			if(t < V[0] || t > V[1])	break;		// 範囲外に出た
			lpcount++;
		}// End while

		// 収束していたら
		if(flag == true){
			pt[anscount] = t;	// 解として登録
			anscount++;
			if(anscount == ptnum){
//				GuiIFB.SetMessage("NURBS_ERROR:range over");
				return KOD_ERR;
			}
		}

	}// End for i

	anscount = CheckTheSamePoints(pt,anscount);		// 同一点を除去する

	return anscount;
}

// Function: CalcNurbsCLength
// NURBS曲線C(t)の全区間の線分長Lを求める
//
// L = S|C'(t)|dt	(Sは積分記号)
//
// 積分は数値積分(ガウス-ルジャンドルの80分点)を用いる
//
// Parameters:
// *Nurb - 対象となるNURBS曲線
//
// Return:
// 線分長
double NURBSC::CalcNurbsCLength(void) const
{
	double g[80] = {-0.9995538226516306298800804990945671849917
		,-0.997649864398237688899494208183122985331
		,-0.994227540965688277892063503664911698088
		,-0.989291302499755531026503167136631385282
		,-0.982848572738629070418288027709116473568
		,-0.974909140585727793385645230069136276245
		,-0.965485089043799251452273155671454998502
		,-0.954590766343634905493481517021029508783
		,-0.942242761309872674752266004500001735070
		,-0.928459877172445795953045959075453133792
		,-0.913263102571757654164733656150947478111
		,-0.896675579438770683194324071967395986307
		,-0.878722567678213828703773343639124407935
		,-0.859431406663111096977192123491656492839
		,-0.838831473580255275616623043902867064793
		,-0.816954138681463470371124994012295707742
		,-0.793832717504605449948639311738454358610
		,-0.769502420135041373865616068749026083985
		,-0.744000297583597272316540527930913673808
		,-0.717365185362099880254068258293815278566
		,-0.689637644342027600771207612438935266089
		,-0.660859898986119801735967122844317234805
		,-0.631075773046871966247928387289336863089
		,-0.600330622829751743154746299164006848430
		,-0.568671268122709784725485786624827158742
		,-0.536145920897131932019857253125400904911
		,-0.502804111888784987593672750367568003564
		,-0.468696615170544477036078364935808657294
		,-0.433875370831756093062386700363181958302
		,-0.398393405881969227024379642517533757117
		,-0.362304753499487315619043286358963588017
		,-0.325664370747701914619112943627358695037
		,-0.288528054884511853109139301434713898496
		,-0.250952358392272120493158816035004797363
		,-0.212994502857666132572388538666321823094
		,-0.174712291832646812559339048011286195718
		,-0.136164022809143886559241078000717067933
		,-0.097408398441584599063278450104936902017
		,-0.058504437152420668628993321883417794425
		,-0.019511383256793997654351234107454547933
		,0.0195113832567939976543512341074545479335
		,0.0585044371524206686289933218834177944254
		,0.0974083984415845990632784501049369020170
		,0.1361640228091438865592410780007170679331
		,0.1747122918326468125593390480112861957188
		,0.2129945028576661325723885386663218230948
		,0.2509523583922721204931588160350047973630
		,0.2885280548845118531091393014347138984964
		,0.3256643707477019146191129436273586950370
		,0.3623047534994873156190432863589635880171
		,0.3983934058819692270243796425175337571172
		,0.4338753708317560930623867003631819583021
		,0.4686966151705444770360783649358086572940
		,0.5028041118887849875936727503675680035649
		,0.5361459208971319320198572531254009049117
		,0.5686712681227097847254857866248271587420
		,0.6003306228297517431547462991640068484301
		,0.6310757730468719662479283872893368630891
		,0.6608598989861198017359671228443172348051
		,0.6896376443420276007712076124389352660897
		,0.7173651853620998802540682582938152785668
		,0.7440002975835972723165405279309136738087
		,0.7695024201350413738656160687490260839854
		,0.7938327175046054499486393117384543586106
		,0.8169541386814634703711249940122957077428
		,0.8388314735802552756166230439028670647936
		,0.8594314066631110969771921234916564928399
		,0.8787225676782138287037733436391244079359
		,0.8966755794387706831943240719673959863073
		,0.9132631025717576541647336561509474781115
		,0.9284598771724457959530459590754531337922
		,0.9422427613098726747522660045000017350708
		,0.9545907663436349054934815170210295087836
		,0.9654850890437992514522731556714549985029
		,0.9749091405857277933856452300691362762450
		,0.9828485727386290704182880277091164735687
		,0.9892913024997555310265031671366313852822
		,0.9942275409656882778920635036649116980888
		,0.9976498643982376888994942081831229853311
		,0.9995538226516306298800804990945671849917
	};
	double w[80] = {0.00114495000318694153454417194131563611869939240558
		,0.0026635335895126816692935358316684554657445542424
		,0.0041803131246948952367393042016813513235494973731
		,0.0056909224514031986492691071171620184769252638347
		,0.0071929047681173127526755708679565074765070381923
		,0.0086839452692608584264094522040342813524060429550
		,0.0101617660411030645208318503524069436640457818796
		,0.0116241141207978269164667699954326348595131815029
		,0.0130687615924013392937868258970563403104186343824
		,0.0144935080405090761169620745834605500559568721551
		,0.0158961835837256880449029092291785257709720926057
		,0.0172746520562693063585842071312909998003110293040
		,0.0186268142082990314287354141521572090084477663361
		,0.0199506108781419989288919287151135633605010642850
		,0.0212440261157820063887107372506131285464689242433
		,0.0225050902463324619262215896861687390205795883718
		,0.0237318828659301012931925246135684162923425291083
		,0.0249225357641154911051178470032198023571024898755
		,0.0260752357675651179029687436002692871256974758292
		,0.0271882275004863806744187066805442598298771757001
		,0.0282598160572768623967531979650145302942654983731
		,0.0292883695832678476927675860195791396612074311446
		,0.0302723217595579806612200100909011747473420675596
		,0.0312101741881147016424428667206035518659997208202
		,0.0321004986734877731480564902872506960895167638325
		,0.0329419393976454013828361809019595361280270376927
		,0.0337332149846115228166751630642387284458265038481
		,0.0344731204517539287943642267310298320767807967429
		,0.0351605290447475934955265923886968812291624523105
		,0.0357943939534160546028615888161544542402361352305
		,0.0363737499058359780439649910465228136600628217876
		,0.0368977146382760088391509965734052192685681011318
		,0.0373654902387304900267053770578386691648069079494
		,0.0377763643620013974897749764263210547707019240195
		,0.0381297113144776383442067915657362019141439239065
		,0.0384249930069594231852124363294901384310218762709
		,0.0386617597740764633270771102671566912609009278398
		,0.0388396510590519689317741826687871658908802293404
		,0.0389583959627695311986255247722608223149320115862
		,0.0390178136563066548112804392527540483295504740296
		,0.0390178136563066548112804392527540483295504740296
		,0.0389583959627695311986255247722608223149320115862
		,0.0388396510590519689317741826687871658908802293404
		,0.0386617597740764633270771102671566912609009278398
		,0.0384249930069594231852124363294901384310218762709
		,0.0381297113144776383442067915657362019141439239065
		,0.0377763643620013974897749764263210547707019240195
		,0.0373654902387304900267053770578386691648069079494
		,0.0368977146382760088391509965734052192685681011318
		,0.0363737499058359780439649910465228136600628217876
		,0.0357943939534160546028615888161544542402361352305
		,0.0351605290447475934955265923886968812291624523105
		,0.0344731204517539287943642267310298320767807967429
		,0.0337332149846115228166751630642387284458265038481
		,0.0329419393976454013828361809019595361280270376927
		,0.0321004986734877731480564902872506960895167638325
		,0.0312101741881147016424428667206035518659997208202
		,0.0302723217595579806612200100909011747473420675596
		,0.0292883695832678476927675860195791396612074311446
		,0.0282598160572768623967531979650145302942654983731
		,0.0271882275004863806744187066805442598298771757001
		,0.0260752357675651179029687436002692871256974758292
		,0.0249225357641154911051178470032198023571024898755
		,0.0237318828659301012931925246135684162923425291083
		,0.0225050902463324619262215896861687390205795883718
		,0.0212440261157820063887107372506131285464689242433
		,0.0199506108781419989288919287151135633605010642850
		,0.0186268142082990314287354141521572090084477663361
		,0.0172746520562693063585842071312909998003110293040
		,0.0158961835837256880449029092291785257709720926057
		,0.0144935080405090761169620745834605500559568721551
		,0.0130687615924013392937868258970563403104186343824
		,0.0116241141207978269164667699954326348595131815029
		,0.0101617660411030645208318503524069436640457818796
		,0.0086839452692608584264094522040342813524060429550
		,0.0071929047681173127526755708679565074765070381923
		,0.0056909224514031986492691071171620184769252638347
		,0.0041803131246948952367393042016813513235494973731
		,0.0026635335895126816692935358316684554657445542424
		,0.0011449500031869415345441719413156361186993924055
	};

	double A = (V[1]+V[0])/2;
	double B = (V[1]-V[0])/2;
	double len=0;

	for(int i=0;i<80;i++){
		double xi = A+B*g[i];
		len += w[i]*(CalcDiffNurbsC(xi).CalcEuclid());
	}
	return(B*len);
}

// Function: CalcNurbsCLength
// NURBS曲線C(t)の指定パラメータ区間[a,b]の線分長Lを求める
//
// L = S|C'(t)|dt	(Sは積分記号)
//
// 積分は数値積分(ガウス-ルジャンドルの80分点)を用いる
//
// Parameters:
// *Nurb - 対象となるNURBS曲線
// a, b - 指定パラメータ区間[a,b]
//
// Return:
// 線分長
double NURBSC::CalcNurbsCLength(double a, double b) const
{
    if(a == b) return 0;

	double g[80] = {-0.9995538226516306298800804990945671849917
		,-0.997649864398237688899494208183122985331
		,-0.994227540965688277892063503664911698088
		,-0.989291302499755531026503167136631385282
		,-0.982848572738629070418288027709116473568
		,-0.974909140585727793385645230069136276245
		,-0.965485089043799251452273155671454998502
		,-0.954590766343634905493481517021029508783
		,-0.942242761309872674752266004500001735070
		,-0.928459877172445795953045959075453133792
		,-0.913263102571757654164733656150947478111
		,-0.896675579438770683194324071967395986307
		,-0.878722567678213828703773343639124407935
		,-0.859431406663111096977192123491656492839
		,-0.838831473580255275616623043902867064793
		,-0.816954138681463470371124994012295707742
		,-0.793832717504605449948639311738454358610
		,-0.769502420135041373865616068749026083985
		,-0.744000297583597272316540527930913673808
		,-0.717365185362099880254068258293815278566
		,-0.689637644342027600771207612438935266089
		,-0.660859898986119801735967122844317234805
		,-0.631075773046871966247928387289336863089
		,-0.600330622829751743154746299164006848430
		,-0.568671268122709784725485786624827158742
		,-0.536145920897131932019857253125400904911
		,-0.502804111888784987593672750367568003564
		,-0.468696615170544477036078364935808657294
		,-0.433875370831756093062386700363181958302
		,-0.398393405881969227024379642517533757117
		,-0.362304753499487315619043286358963588017
		,-0.325664370747701914619112943627358695037
		,-0.288528054884511853109139301434713898496
		,-0.250952358392272120493158816035004797363
		,-0.212994502857666132572388538666321823094
		,-0.174712291832646812559339048011286195718
		,-0.136164022809143886559241078000717067933
		,-0.097408398441584599063278450104936902017
		,-0.058504437152420668628993321883417794425
		,-0.019511383256793997654351234107454547933
		,0.0195113832567939976543512341074545479335
		,0.0585044371524206686289933218834177944254
		,0.0974083984415845990632784501049369020170
		,0.1361640228091438865592410780007170679331
		,0.1747122918326468125593390480112861957188
		,0.2129945028576661325723885386663218230948
		,0.2509523583922721204931588160350047973630
		,0.2885280548845118531091393014347138984964
		,0.3256643707477019146191129436273586950370
		,0.3623047534994873156190432863589635880171
		,0.3983934058819692270243796425175337571172
		,0.4338753708317560930623867003631819583021
		,0.4686966151705444770360783649358086572940
		,0.5028041118887849875936727503675680035649
		,0.5361459208971319320198572531254009049117
		,0.5686712681227097847254857866248271587420
		,0.6003306228297517431547462991640068484301
		,0.6310757730468719662479283872893368630891
		,0.6608598989861198017359671228443172348051
		,0.6896376443420276007712076124389352660897
		,0.7173651853620998802540682582938152785668
		,0.7440002975835972723165405279309136738087
		,0.7695024201350413738656160687490260839854
		,0.7938327175046054499486393117384543586106
		,0.8169541386814634703711249940122957077428
		,0.8388314735802552756166230439028670647936
		,0.8594314066631110969771921234916564928399
		,0.8787225676782138287037733436391244079359
		,0.8966755794387706831943240719673959863073
		,0.9132631025717576541647336561509474781115
		,0.9284598771724457959530459590754531337922
		,0.9422427613098726747522660045000017350708
		,0.9545907663436349054934815170210295087836
		,0.9654850890437992514522731556714549985029
		,0.9749091405857277933856452300691362762450
		,0.9828485727386290704182880277091164735687
		,0.9892913024997555310265031671366313852822
		,0.9942275409656882778920635036649116980888
		,0.9976498643982376888994942081831229853311
		,0.9995538226516306298800804990945671849917
	};
	double w[80] = {0.00114495000318694153454417194131563611869939240558
		,0.0026635335895126816692935358316684554657445542424
		,0.0041803131246948952367393042016813513235494973731
		,0.0056909224514031986492691071171620184769252638347
		,0.0071929047681173127526755708679565074765070381923
		,0.0086839452692608584264094522040342813524060429550
		,0.0101617660411030645208318503524069436640457818796
		,0.0116241141207978269164667699954326348595131815029
		,0.0130687615924013392937868258970563403104186343824
		,0.0144935080405090761169620745834605500559568721551
		,0.0158961835837256880449029092291785257709720926057
		,0.0172746520562693063585842071312909998003110293040
		,0.0186268142082990314287354141521572090084477663361
		,0.0199506108781419989288919287151135633605010642850
		,0.0212440261157820063887107372506131285464689242433
		,0.0225050902463324619262215896861687390205795883718
		,0.0237318828659301012931925246135684162923425291083
		,0.0249225357641154911051178470032198023571024898755
		,0.0260752357675651179029687436002692871256974758292
		,0.0271882275004863806744187066805442598298771757001
		,0.0282598160572768623967531979650145302942654983731
		,0.0292883695832678476927675860195791396612074311446
		,0.0302723217595579806612200100909011747473420675596
		,0.0312101741881147016424428667206035518659997208202
		,0.0321004986734877731480564902872506960895167638325
		,0.0329419393976454013828361809019595361280270376927
		,0.0337332149846115228166751630642387284458265038481
		,0.0344731204517539287943642267310298320767807967429
		,0.0351605290447475934955265923886968812291624523105
		,0.0357943939534160546028615888161544542402361352305
		,0.0363737499058359780439649910465228136600628217876
		,0.0368977146382760088391509965734052192685681011318
		,0.0373654902387304900267053770578386691648069079494
		,0.0377763643620013974897749764263210547707019240195
		,0.0381297113144776383442067915657362019141439239065
		,0.0384249930069594231852124363294901384310218762709
		,0.0386617597740764633270771102671566912609009278398
		,0.0388396510590519689317741826687871658908802293404
		,0.0389583959627695311986255247722608223149320115862
		,0.0390178136563066548112804392527540483295504740296
		,0.0390178136563066548112804392527540483295504740296
		,0.0389583959627695311986255247722608223149320115862
		,0.0388396510590519689317741826687871658908802293404
		,0.0386617597740764633270771102671566912609009278398
		,0.0384249930069594231852124363294901384310218762709
		,0.0381297113144776383442067915657362019141439239065
		,0.0377763643620013974897749764263210547707019240195
		,0.0373654902387304900267053770578386691648069079494
		,0.0368977146382760088391509965734052192685681011318
		,0.0363737499058359780439649910465228136600628217876
		,0.0357943939534160546028615888161544542402361352305
		,0.0351605290447475934955265923886968812291624523105
		,0.0344731204517539287943642267310298320767807967429
		,0.0337332149846115228166751630642387284458265038481
		,0.0329419393976454013828361809019595361280270376927
		,0.0321004986734877731480564902872506960895167638325
		,0.0312101741881147016424428667206035518659997208202
		,0.0302723217595579806612200100909011747473420675596
		,0.0292883695832678476927675860195791396612074311446
		,0.0282598160572768623967531979650145302942654983731
		,0.0271882275004863806744187066805442598298771757001
		,0.0260752357675651179029687436002692871256974758292
		,0.0249225357641154911051178470032198023571024898755
		,0.0237318828659301012931925246135684162923425291083
		,0.0225050902463324619262215896861687390205795883718
		,0.0212440261157820063887107372506131285464689242433
		,0.0199506108781419989288919287151135633605010642850
		,0.0186268142082990314287354141521572090084477663361
		,0.0172746520562693063585842071312909998003110293040
		,0.0158961835837256880449029092291785257709720926057
		,0.0144935080405090761169620745834605500559568721551
		,0.0130687615924013392937868258970563403104186343824
		,0.0116241141207978269164667699954326348595131815029
		,0.0101617660411030645208318503524069436640457818796
		,0.0086839452692608584264094522040342813524060429550
		,0.0071929047681173127526755708679565074765070381923
		,0.0056909224514031986492691071171620184769252638347
		,0.0041803131246948952367393042016813513235494973731
		,0.0026635335895126816692935358316684554657445542424
		,0.0011449500031869415345441719413156361186993924055
	};

	double A = (b+a)/2;
	double B = (b-a)/2;
	double len=0;

	for(int i=0;i<80;i++){
		double xi = A+B*g[i];
		len += w[i]*(CalcDiffNurbsC(xi).CalcEuclid());
	}
	return(B*len);
}

// Function: CalcTanVecOnNurbsC
// NURBS曲線上のtにおける単位接ベクトルをもとめる
//
// Parameters:
// *C - NURBS曲線へのポインタ
// t - ノット値
//
// Retrurn:
// 計算結果
Coord NURBSC::CalcTanVecOnNurbsC(double t) const
{
//	return NormalizeVec(CalcDiffNurbsC(C,t));
    return CalcDiffNurbsC(t).NormalizeVec();
}

// Function: CalcCurvatureNurbsC
// NURBS曲線の曲率を求める
//
// Parameters:
// *C - NURBS曲線へのポインタ
// t - ノット値
//
// Retrurn:
// 計算結果
double NURBSC::CalcCurvatureNurbsC(double t) const
{
	Coord p_  = CalcDiffNurbsC(t);
	Coord p__ = CalcDiff2NurbsC(t);

//	return(CalcEuclid(CalcOuterProduct(p_,p__))/pow(CalcEuclid(p_),3));
	return (p_&&p__).CalcEuclid()/pow(p_.CalcEuclid(),3);
}

// Function: DivNurbsC
// NURBS曲線を指定した位置（端からの弧長）で分割する
//
// Parameters:
// *C0 - 分割するNURBS曲線へのポインタ        
// *C1 - 分割されたNURBS曲線へのポインタ
// *C2 - 分割されたNURBS曲線へのポインタ     
// L - 端からの弧長
//
// Return:
// 成功：KOD_TRUE, 失敗：KOD_FALSE 
boost::tuple<NURBSC*, NURBSC*> NURBSC::DivNurbsC(double L) const
{
	double dLEN = CalcNurbsCLength();					// NURBS曲線の線分長を得る
	double t_init = (V[1] - V[0])*L/dLEN;				// tの初期値をセット
	double t = CalcParamLengthOnNurbsC(L,t_init);		// 分割点パラメータ値取得

	NURBSC* C1;
	NURBSC* C2;
	boost::tie(C1, C2) = DivNurbsCParam(t);				// 分割

	return boost::make_tuple(C1, C2);
}

// Function: DivNurbsCParam
// NURBS曲線を指定したパラメータ値で分割する
//
// Parameters:
// *C0 - 分割するNURBS曲線へのポインタ        
// *C1 - 分割されたNURBS曲線へのポインタ
// *C2 - 分割されたNURBS曲線へのポインタ    
// t - 分割位置を表す曲線パラメータ
//
// Return:
// 成功：KOD_TRUE, 失敗：KOD_FALSE 
boost::tuple<NURBSC*, NURBSC*> NURBSC::DivNurbsCParam(double t) const
{
	// tパラメータが適正範囲か
	if(t <= T[0] || t >= T[N-1]){
//		GuiIFB.SetMessage("NURBS_Func ERROR: Wrong Curve Parameter is set.");
		NURBSC* nurb = NULL;
		return boost::make_tuple(nurb, nurb);
	}

	int deg = M - 1;		// 多重度

	// 分割の下準備
	// 分割用曲線C0_を準備する
	NURBSC	C0_;
	C0_.K = K + deg;
	C0_.N = M + C0_.K;
	C0_.T.resize(C0_.N);
	C0_.W.resize(C0_.K);
	C0_.cp.resize(boost::extents[C0_.K]);

	// C0のノットベクトルにtと同じ値がある場合は，多重度を1つ落とす
	for(int i=0;i<N;i++){
		if(t == T[i])	deg--;
	}

	// 分割位置パラメータtをC0_に挿入する
	int k = InsertNewKnotOnNurbsC(&C0_,t,deg);

	// 2本の分割曲線を生成
	int N1 = k+1;
	int K1 = N1 - M;
	int N2 = C0_.N - k + deg+1;
	int K2 = N2 - M;

	ublasVector T1(N1);
	ublasVector W1(K1);
	ACoord  cp1(boost::extents[K1]);
	ublasVector T2(N2);
	ublasVector W2(K2);
	ACoord  cp2(boost::extents[K2]);

	// ノットベクトル，コントロールポイント，ウェイトをC1,C2に分配
	for(int i=0;i<N1-1;i++)
		T1[i] = C0_.T[i];
	T1[N1-1] = t;
	for(int i=0;i<K1;i++){
		cp1[i] = C0_.cp[i];
		W1[i] = C0_.W[i];
	}
	for(int i=0;i<M;i++)
		T2[i] = t;
	for(int i=M;i<N2;i++)
		T2[i] = C0_.T[k+i-M];
	for(int i=0;i<K2;i++){
		cp2[i] = C0_.cp[i+K1-1];
		W2[i] = C0_.W[i+K1-1];
	}

	// debug
	//fprintf(stderr,"C0:%d,%d\n",K,N);
	//fprintf(stderr,"C0_:%d,%d\n",C0_.K,C0_.N);
	//fprintf(stderr,"C1:%d,%d\n",K1,N1);
	//fprintf(stderr,"C2:%d,%d\n",K2,N2);
	//fprintf(stderr,"\n");
	//for(int i=0;i<C0_.N;i++)
	//	fprintf(stderr,"%d:%lf\n",i+1,C0_.T[i]);
	//fprintf(stderr,"\n");
	//for(int i=0;i<N1;i++)
	//	fprintf(stderr,"%d:%lf\n",i+1,T1[i]);
	//fprintf(stderr,"\n");
	//for(int i=0;i<N2;i++)
	//	fprintf(stderr,"%d:%lf\n",i+1,T2[i]);

	// ノットの範囲を0-1に変更
	ChangeKnotVecRange(T1,N1,M,K1,0,1);
	ChangeKnotVecRange(T2,N2,M,K2,0,1);

	// C1,C2生成
	NURBSC* C1 = new NURBSC(K1,M,N1,T1,W1,cp1,V,prop,0);
	NURBSC* C2 = new NURBSC(K2,M,N2,T2,W2,cp2,V,prop,0);

	return boost::make_tuple(C1, C2);
}

// Function: ConnectNurbsC
// 2本のNURBS曲線を連結する
//
// Parameter:
// *C1 - 曲線1
// *C2 - 曲線2
// *C_ - 連結後の曲線を格納
//
// Return:
// 成功：KOD_TRUE,  失敗：KOD_FALSE
int NURBSC::ConnectNurbsC(const NURBSC *C2, NURBSC* C_) const
{
	int flag = -1;		// 連結位置判別用フラグ

	// 2曲線の連結位置を調べ，連結点がC1(1), C2(0)となるようどちらかの曲線を調整する
	if(C1->cp[0].DiffCoord(C2->cp[0]) == KOD_TRUE){
		ReverseNurbsC(C1);				// C1の向きを反転する
	}
	else if(C1->cp[0].DiffCoord(C2->cp[C2->K-1]) == KOD_TRUE){
		NURBSC *C;
		C = C2;
		C2 = C1;
		C1 = C;
	}
	else if(C1->cp[C1->K-1].DiffCoord(C2->cp[0]) == KOD_TRUE){
		// このケースはOK．特に調整必要なし
	}
	else if(C1->cp[C1->K-1].DiffCoord(C2->cp[C2->K-1]) == KOD_TRUE){
		ReverseNurbsC(C2);				// C2の向きを反転する
	}
	else{
//		GuiIFB.SetMessage("NURBS_Func ERROR: Two Curves don't share the same coordinate value.");
		return KOD_ERR;
	}

	// 2曲線の階数が等しいこと
	if(C1->M != C2->M){
//		GuiIFB.SetMessage("NURBS_Func ERROR: Two Curves don't have the same rank.");
		return KOD_ERR;
	}

	int K = C1->K + C2->K - 1;				// C_のコントロールポイントの数
	int N = C1->N + C2->N - C2->M - 1;		// C_のノットベクトルの数

	New_NurbsC(C_,K,N);						// C_内のメモリー確保

	SetKnotVecC_ConnectC(C1,C2,C_);			// C_のノット定義域を指定

	SetCPC_ConnectC(C1,C2,C_);				// C_のコントロールポイントとウェイトを指定

	//for(int i=0;i<C_->N;i++)
	//	fprintf(stderr,"%d,%lf\n",i+1,C_->T[i]);
	//fprintf(stderr,"\n");
	//for(int i=0;i<C_->K;i++)
	//	fprintf(stderr,"%d,%lf,%lf,%lf,%lf\n",i+1,C_->cp[i].x,C_->cp[i].y,C_->cp[i].z,C_->W[i]);

	C_->M = C1->M;							// C_の階数を指定

	for(int i=0;i<4;i++)
		C_->prop[i] = C1->prop[i];
	C_->EntUseFlag = C1->EntUseFlag;
    C_->BlankStat = C1->BlankStat;

	return KOD_TRUE;
}

// Function: CalcParamLengthOnNurbsC
// NURBS曲線において一端からの指定距離におけるパラメータ値を返す
//
// Parameters:
// *C - NURBS曲線
// L - 指定距離
// Init_t - 解探索の初期パラメータ
//
// Return:
// 指定距離におけるパラメータ値
double NURBSC::CalcParamLengthOnNurbsC(double L, double Init_t) const
{
	double dt = 1E+12;			// ステップサイズパラメータの初期値
	double t = Init_t;
	int count = 0;

	while(fabs(dt) > APPROX_ZERO){
		dt = (L - CalcNurbsCLength(0,t))/CalcDiffNurbsC(t).CalcEuclid()/2;		// ニュートン法による収束計算
		t += dt;
		if(count > LOOPCOUNTMAX || t > V[1]){
//			GuiIFB.SetMessage("NURBS_Func ERROR: Cannot find a anser");
			break;
		}
		//fprintf(stderr,"%d:  t = %lf,    dt = %lf\n",k,t,dt);	// debug
	}

	return t;
}

// Function: CalcDeltaPtsOnNurbsC
// 指定した間隔でNURBS曲線上の座標値を出力する
//
// Parameters:
// *Nurb - NURBS曲線へのポインタ  
// D - 間隔  
// *Pts - 出力される座標値を格納
//
// Return:
// 点数（Dが0，あるいは指定したNURBS曲線の全長より長かった場合は，KOD_ERR）
int NURBSC::CalcDeltaPtsOnNurbsC(double D, ACoord& Pts) const
{
	if(D == 0){
//		GuiIFB.SetMessage("NURBS_Func ERROR: Set Correct Interval Value");
		return KOD_ERR;
	}

	double L = CalcNurbsCLength();		// NURBS曲線の線分長を得る
	if(D > L){
//		GuiIFB.SetMessage("NURBS_Func ERROR: Arc Length > Whole Lenth of the Curve");
	}
	//fprintf(stderr,"L = %lf\n",L);		// debug
	//fprintf(stderr,"D = %lf\n",D);		// debug

	int k=1;			// 分割カウンタ
	double t = (V[1] - V[0])/(L/D);	// tの初期値をセット

	while(t <= V[1]){
		t = CalcParamLengthOnNurbsC((double)k*D,t);	// 解を探索
		Pts[k-1] = CalcNurbsCCoord(t);		// 解を登録
		k++;
		t = k*(V[1] - V[0])/(L/D);	// 次のtの初期値をセット
	}

	return k-1;
}

// Function: ShiftNurbsC
// NURBS曲線のシフト
// 
// Parameters:
// *nurbs - 変更されるNURBS曲線  
// shift - シフト量
void NURBSC::ShiftNurbsC(const Coord& shift)
{
	for(int i=0;i<K;i++){
		cp[i] += shift;
	}
}

// Function: ChRatioNurbsC
// NURBS曲線の倍率を変更する
//
// Parameters:
// *nurbs - 変更されるNURBS曲線  
// ratio - 倍率
void NURBSC::ChRatioNurbsC(const Coord& ratio)
{
	for(int i=0;i<K;i++){
		cp[i] *= ratio;
	}
}

// Function: RotNurbsC
// NURBS曲面をDベクトル回りにdeg(°)だけ回転させる
//
// Parameters:
// *nurbs - 変更されるNURBS曲線　
// axis - 回転軸の単位ベクトル　
// deg - 角度(degree)
void NURBSC::RotNurbsC(const Coord& axis, double deg)
{
	double rad;			// ラジアン格納用
	QUATERNION QFunc;	// クォータニオン関連の関数を集めたクラスのオブジェクトを生成
	Quat StartQ;		// 回転前の座標を格納するクォータニオン
	Quat RotQ;			// 回転クォータニオン
	Quat ConjuQ;		// 共役クォータニオン
	Quat TargetQ;		// 回転後の座標を格納するクォータニオン
	
	for(int i=0;i<K;i++){		// コントロールポイント分ループ
		StartQ = QFunc.QInit(1,cp[i].x,cp[i].y,cp[i].z);		// NURBS曲面を構成するcpの座標を登録
		rad = DegToRad(deg);									// degreeからradianに変換
		RotQ = QFunc.QGenRot(rad,axis.x,axis.y,axis.z);			// 回転クォータニオンに回転量を登録(ここの数字をいじれば任意に回転できる)
		ConjuQ = QFunc.QConjugation(RotQ);						// RotQの共役クォータニオンを登録
		TargetQ = QFunc.QMult(QFunc.QMult(RotQ,StartQ),ConjuQ);	// 回転させる
		cp[i].SetCoord(TargetQ.x,TargetQ.y,TargetQ.z);	// 回転後の座標を登録
	}
}

// Function: ReverseNurbsC
// NURBS曲線のノットベクトル向きを反転する
//
// Parameters:
// *C - NURBS曲線 
void NURBSC::ReverseNurbsC(void)
{
	std::reverse(W.begin(), W.end());		// Reverse(C->W,C->K);
	std::reverse(cp.begin(),cp.end());	// Reverse(C->cp,C->K);
	std::reverse(T.begin(), T.end());		// Reverse(C->T,C->N);
	for(int i=0;i<N;i++)
		T[i] *= -1;
    ChangeKnotVecRange(T,N,M,K,0,1);
}

///////////////////////////////////////////////////////////
// privateメンバ関数

// Function: GetNurbsCCoef
// (private)CalcIntersecCurve3()のサブ関数．NURBS曲線の係数を求める(最高3次)
// 
// Parameters:
// *nurb - 対象となるNURBS曲線 
// **coef - Bスプライン基底関数の係数 
// i - 曲線の番号 
// *P, *Q - NURBS曲線の係数(P,Q) 
//
// Return:
// 成功：KOD_TRUE, 失敗：KOD_ERR
int NURBSC::GetNurbsCCoef(const ublasMatrix& coef, int i, ACoord& P, ublasVector& Q) const
{
	for(int j=0;j<M;j++){
		P[j] = 0;
		Q[j] = 0;
	}

	for(int j=0;j<M;j++){
		for(int k=0;k<M;k++){
			Q[j] += coef(k,j)*W[i+k];
			P[j] += cp[i+k] * (coef(k,j)*W[i+k]);
		}
	}
	
	return KOD_TRUE;
}

// Function: InsertNewKnotOnNurbsC
// (private)NURBS曲線に新たなノットを挿入する
//
// Parameters:
// *C - 元のNURBS曲線  
// *C_ - 挿入対象のNURBS曲線     
// t - 挿入するノット     
// deg - 多重度
//
// Return:
// 新たなノットベクトル列におけるtの挿入位置
int NURBSC::InsertNewKnotOnNurbsC(NURBSC* C_, double t, int deg) const
{
	int k=0;					// tの挿入位置
	int m = M;				// 階数
	int n = K;				// コントロールポイントの数

	ublasVector T_buf(K+M+deg);		// ノットベクトル一時格納用バッファ
	ACoord cp_buf(boost::extents[K+deg]);// コントロールポイント一時格納用バッファ
	ublasVector W_buf(K+deg);			// ウェイト一時格納用バッファ

	// C_に元のNURBS曲線のT,cp,Wを初期値として代入
	for(int i=0;i<m+n;i++)
		C_->T[i] = T[i];
	for(int i=0;i<n;i++)
		C_->cp[i] = cp[i];
	for(int i=0;i<n;i++)
		C_->W[i] = W[i];

	// 多重度分，tの挿入を繰り返す
	for(int count=0;count<deg;count++){
		// 各bufにC_のT,cp,Wを代入
		for(int i=0;i<n+m;i++)
			T_buf[i] = C_->T[i];
		for(int i=0;i<n;i++)
			cp_buf[i] = C_->cp[i];
		for(int i=0;i<n;i++)
			W_buf[i] = C_->W[i];

		// tの挿入位置kを調べる
		k=0;
		for(int i=0;i<n+m-1;i++){
			if(t >= T_buf[i] && t < T_buf[i+1]){
				k = i;
				break;
			}
		}

		// C_のノットベクトルを更新
		for(int i=0;i<=k;i++)
			C_->T[i] = T_buf[i];
		C_->T[k+1] = t;
		for(int i=k+2;i<=n+m;i++)
			C_->T[i] = T_buf[i-1];

		// コントロールポイントとウェイトの更新
		for(int i=0;i<=k-m+1;i++){
			C_->cp[i] = cp_buf[i];
			C_->W[i] = W_buf[i];
		}
		for(int i=k-m+2;i<=k;i++){
			double a = (t-T_buf[i])/(T_buf[i+m-1]-T_buf[i]);
			C_->cp[i] = (cp_buf[i-1]*(1-a))+(cp_buf[i]*a);
			C_->W[i] = (1-a)*W_buf[i-1] + a*W_buf[i];
		}
		for(int i=k+1;i<=n;i++){
			C_->cp[i] = cp_buf[i-1];
			C_->W[i] = W_buf[i-1];
		}

		n++;
	}

	return k+2;
}

// Function: InsertNewKnotOnNurbsC
// (private)NURBS曲線に新たなノットを挿入する
//
// Parameters:
// *C - 元のNURBS曲線  
// *C_ - 挿入対象のNURBS曲線     
// t - 挿入するノット     
// deg - 多重度
//
// Return:
// 新たなノットベクトル列におけるtの挿入位置
int NURBSC::InsertNewKnotOnNurbsC(NURBSC* C_, double t, int deg) const
{
	int k=0;					// tの挿入位置
	int m = M;				// 階数
	int n = K;				// コントロールポイントの数

	ublasVector T_buf(K+M+deg);		// ノットベクトル一時格納用バッファ
	ACoord cp_buf(boost::extents[K+deg]);// コントロールポイント一時格納用バッファ
	ublasVector W_buf(K+deg);			// ウェイト一時格納用バッファ
	//double T_buf[K+M+deg];
	//Coord  cp_buf[K+deg];
	//double W_buf[K+deg];


	// C_に元のNURBS曲線のT,cp,Wを初期値として代入
	for(int i=0;i<m+n;i++)
		C_->T[i] = T[i];
	for(int i=0;i<n;i++)
		C_->cp[i] = cp[i];
	for(int i=0;i<n;i++)
		C_->W[i] = W[i];

	// 多重度分，tの挿入を繰り返す
	for(int count=0;count<deg;count++){
		// 各bufにC_のT,cp,Wを代入
		for(int i=0;i<n+m;i++)
			T_buf[i] = C_->T[i];
		for(int i=0;i<n;i++)
			cp_buf[i] = C_->cp[i];
		for(int i=0;i<n;i++)
			W_buf[i] = C_->W[i];

		// tの挿入位置kを調べる
		k=0;
		for(int i=0;i<n+m-1;i++){
			if(t >= T_buf[i] && t < T_buf[i+1]){
				k = i;
				break;
			}
		}

		// C_のノットベクトルを更新
		for(int i=0;i<=k;i++)
			C_->T[i] = T_buf[i];
		C_->T[k+1] = t;
		for(int i=k+2;i<=n+m;i++)
			C_->T[i] = T_buf[i-1];

		// コントロールポイントとウェイトの更新
		for(int i=0;i<=k-m+1;i++){
			C_->cp[i] = cp_buf[i];
			C_->W[i] = W_buf[i];
		}
		for(int i=k-m+2;i<=k;i++){
			double a = (t-T_buf[i])/(T_buf[i+m-1]-T_buf[i]);
			C_->cp[i] = (cp_buf[i-1]*(1-a))+(cp_buf[i]*a);
			C_->W[i] = (1-a)*W_buf[i-1] + a*W_buf[i];
		}
		for(int i=k+1;i<=n;i++){
			C_->cp[i] = cp_buf[i-1];
			C_->W[i] = W_buf[i-1];
		}

		n++;
	}

	return k+2;
}

///////////////////////////////////////////////////////////

// Function: DebugForNurbsC
// NURBS曲線情報をデバッグプリント
//
// Parameters:
// *nurbs - デバッグするNURBS曲線
void NURBSC::DebugForNurbsC(void) const
{
	fprintf(stderr,"Cp num: %d\n",K);
	fprintf(stderr,"Rank: %d\n",M);
	fprintf(stderr,"Knot num: %d\n",N);
	fprintf(stderr,"Knot range: %lf - %lf\n",V[0], V[1]);

	// コントロールポイント
	fprintf(stderr,"Control Point\n");
	for(int i=0;i<K;i++){
		fprintf(stderr,"#%d: (%lf,%lf,%lf)\t",i+1,cp[i].x,cp[i].y,cp[i].z);
	}
	fprintf(stderr,"\n");

	// ノットシーケンス
	fprintf(stderr,"Knot Vector\t");
	for(int i=0;i<K+M;i++){
		fprintf(stderr,"#%d: %lf\t",i+1,T[i]);
	}
	fprintf(stderr,"\n");

	// ウェイト
	fprintf(stderr,"Weight\n");
	for(int i=0;i<K;i++){
		fprintf(stderr,"#%d: %lf\t",i+1,W[i]);
	}
}
